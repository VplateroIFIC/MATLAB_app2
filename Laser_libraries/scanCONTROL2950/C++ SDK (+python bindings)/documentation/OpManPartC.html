<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta http-equiv="Content-Language" content="en-gb">
  <meta http-equiv="X-UA-Compatible" content="IE=9">
  <meta name="GENERATOR" content="nvu 1.0">
  <meta name="COPYRIGHT" content="MICRO-OPTRONIC MESSTECHNIK GMBH">
  <meta name="author" content="Tobias Schüller">
  <meta http-equiv="EXPIRES" content="0">
  <meta http-equiv="PRAGMA" content="no-cache">
  <meta name="ROBOTS" content="index,follow">
  <meta name="REVISIT-AFTER" content="7 days">
  <meta name="keywords" content="instruction file">
  <title>scanCONTROL Post Processing</title>
  <style type="text/css">
TABLE { background: #f0f0f0; }
CAPTION { font-weight: bold; }
ACRONYM { color: #CC0000;}
  </style>
</head>
<body>
<table style="background-color: rgb(255, 255, 255);" summary="page header" frame="box" width="100%" cellspacing="1" cellpadding="3" border="1">
  <tbody>
    <tr>
      <td align="center">
      <h1>Post Processing of Profiles</h1>
      <h1>with scan<acronym>CONTROL</acronym>&nbsp;2810
      </h1>
      </td>
      <td align="center"> <img src="OpManPartC-Dateien/CompanyLogo.gif" alt="MICRO-OPTRONIC" border="0" align="middle"></td>
    </tr>
    <tr>
      <td align="center">
      <h2>Supplement C to the scan<acronym>CONTROL</acronym>
Manual</h2>
      </td>
      <td align="center">$Revision: 7a562798a54f $<br>
$Date: 2019/04/12 07:43:02 $</td>
    </tr>
    <tr>
      <td align="center">©
Micro-Optronic-Messtechnik GmbH, Lessingstr. 14, D-01465 Dresden
(Langebrück), Germany<br>
e-mail <a href="mailto:info@micro-optronic.de">info@micro-optronic.de</a></td>
      <td align="center"><a href="http://www.micro-optronic.de/">www.micro-optronic.de</a></td>
    </tr>
  </tbody>
</table>
<br>
<h2><a name="contents"></a>Contents</h2>
<ul>
  <li><a href="#about">About this Document</a></li>
  <li><a href="#general">General</a> </li>
  <li><a href="#param">Module Parameter Queue</a>
  </li>
  <li><a href="#result">Module Result Queue</a>
  </li>
  <li><a href="#pan">Accessing the Module Parameter
Queue with the PAN Register</a> </li>
  <li><a href="#m0">Module 0: End of Queue</a>
  </li>
  <li><a href="#m1">Module 1: Cut</a> </li>
  <li><a href="#m2">Module 2: Bead Finder</a> </li>
  <li><a href="#m3">Module 3: Formula</a> </li>
  <li><a href="#m4">Module 4: GetOutput</a></li>
  <li><a href="#m4Ex">Module 4: GetOutputExtended</a></li>
  <li><a href="#m5">Module 5: Filter</a></li>
  <li><a href="#m6">Module 6: Comment</a></li>
  <li><a href="#m7">Module 7: GetTimestamp</a></li>
  <li><a href="#m8">Module 8: WAGObuscoupler</a></li>
  <li><a href="#m9">Module 9: GetHoldingRegisters</a></li>
  <li><a href="#m10">Module 10: Gap Finder</a></li>
  <li><a href="#m11">Module 11: GetInfo</a></li>
  <li><a href="#m12">Module 12: MeasurementServer</a></li>
  <li><a href="#m13">Module 13: GetProfileInfo</a></li>
  <li><a href="#m14">Module 14: CircleFit</a></li>
  <li><a href="#m128">Module 128: gapCONTROL Results</a></li>
  <li><a href="#m129">Module 129: ConfigTools Results</a></li>
  <li><a href="#m130">Module 130: Application Results</a></li>
  <li><a href="#m131">Module 131: General Results</a></li>
</ul>
<h2><a name="about">About this Document</a></h2>
<p>This document describes the interface of the programmable post
processing modules. In other words, it specifies a programming
language. Different components like device firmware, demo programmes
and configuration tools rely on specific revisions of the specification
making a clear revision management absolutely necessary. The following
table summarises&nbsp;the existing revisions and where they are
implemented. The rest of the document, of course, reflects only the
most recent revision.</p>
<table width="100%" cellspacing="2" cellpadding="2" border="1">
  <tbody>
    <tr>
      <th colspan="1" rowspan="2">Revision</th>
      <th colspan="1" rowspan="2">Description and
Changes</th>
      <th colspan="3" rowspan="1">Device Firmware
Implementations</th>
      <th colspan="2" rowspan="1">Software Tool
Implementations</th>
    </tr>
    <tr>
      <th>scan<acronym>CONTROL</acronym>&nbsp;2810</th>
      <th>scan<acronym>CONTROL</acronym>&nbsp;2710</th>
      <th>scan<acronym>CONTROL</acronym>&nbsp;2610<br>
scan<acronym>CONTROL</acronym>&nbsp;2910</th>
      <th>QueueConfig</th>
      <th>QueueCompiler</th>
    </tr>
    <tr>
      <td align="center">1.14</td>
      <td>
      <ul>
        <li>enlarge quadlet offset for
        <ul>
            <li><a href="#m2">BeadFinder</a>
            </li><li><a href="#func_load">Formula func(load)</a>
            </li><li><a href="#func_load-write">Fromula func(load-write)</a>
            </li><li><a href="#func_save">Formula func(save)</a>
            </li><li><a href="#m4">GetOutput</a>
            </li><li><a href="#m4Ex">GetOutputExtended</a>
            </li><li><a href="#m6">Comment</a>
            </li><li><a href="#m7">GetTimestamp</a>
            </li><li><a href="#m9">GetHoldingRegisters</a>
            </li><li><a href="#m10">Gap Finder</a>
            </li><li><a href="#m11">GetInfo</a>
            </li><li><a href="#m13">GetProfileInfo</a>
        </li></ul>
        </li><li>enhanced <a href="#m10">Gap Finder</a> Modul, optional error code</li>
      </ul>
      </td>
      <td align="center">not available</td>
      <td align="center">not available</td>
      <td align="center">v45-xx</td>
      <td align="center"><br>
      </td><td align="center">1.10.0</td>

    </tr><tr>
      <td align="center">1.13</td>
      <td>
      <ul>
        <li>added <a href="#m13">GetProfileInfo</a> Modul</li>
      </ul>
      </td>
      <td align="center">not available</td>
      <td align="center">v34-xx</td>
      <td align="center">v41-xx</td>
      <td align="center"></td>
      <td align="center"></td>

    </tr>
    <tr>
      <td align="center">1.12</td>
      <td>
      <ul>
        <li>extended <a href="#m11">GetInfo</a></li>
        <li>for scan<acronym>CONTROL</acronym>&nbsp;2710, scan<acronym>CONTROL</acronym>&nbsp;2610 and scan<acronym>CONTROL</acronym>&nbsp;2910 <a href="#m4">GetOutput</a>
            is replaced by <a href="#m4ex">GetOutputExtended</a></li>
      </ul>
      </td>
      <td align="center">not available</td>
      <td align="center">v34-xx</td>
      <td align="center">v41-xx</td>
      <td align="center"></td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.11</td>
      <td>
      <ul>
        <li>support minimum parameter for <a href="#m5">FillGaps</a> and <a href="#m5">FillGapsAll</a> filter types</li>
        <li>added <a href="#m5">Join</a> and <a href="#m5">JoinAll</a> filter types</li>
      </ul>
      </td>
      <td align="center">not available</td>
      <td align="center">v33-xx</td>
      <td align="center">v38-xx</td>
      <td align="center">Alpha-01-04-2015</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.10</td>
      <td>
      <ul>
        <li><a href="#m2">bead finder</a>,&nbsp;support
arbitrary result quadlett as anchor point</li>
        <li> <a href="#m1"> </a><a href="#m5">Clip</a> type filters,&nbsp;support
arbitrary result quadlett as anchor point</li>
        <li>added a&nbsp;<a href="#m11">GetInfo</a>
module for sensor temperatur, elapsed time for profile
processing&nbsp;</li>
        <li><a href="#m8">WAGO
buscoupler 750-339</a>, support inversion of digital outputs</li>
        <li>added a <a href="#m12">MeasurementServer</a>&nbsp;module</li>
      </ul>
      </td>
      <td align="center">v32-xx</td>
      <td align="center">v32-xx</td>
      <td align="center">v32-xx</td>
      <td align="center">&nbsp;</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.9</td>
      <td>
      <ul>
        <li><a href="#m2">bead finder</a>
changed, calculate only one center of gravity in case of&nbsp;only
one
reference
level and orientation (ref=<tt>00<sub>b</sub></tt>)</li>
      </ul>
      </td>
      <td align="center">&nbsp;</td>
      <td align="center">v31-xx</td>
      <td align="center">v31-xx</td>
      <td align="center">Alpha-14-03-2013</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.8</td>
      <td>
      <ul>
        <li><a href="#m2">bead finder</a>
optimised, interpolation can be done in any case now</li>
        <li><a href="#m2">bead finder</a>
can calculate center of gravity and distance to origin</li>
        <li>added a <a href="#func_project-point">ProjectPoint</a>
command to the formula module</li>
        <li>updated <a href="#func_write-serial">if-write-serial</a>
command of the formula module to output binary strings</li>
        <li>added <a href="#m5">Split</a>, <a href="#m5">SplitAll</a> filter types</li>
      </ul>
      </td>
      <td align="center">v30-D2</td>
      <td align="center">v30-xx</td>
      <td></td>
      <td align="center">Alpha-14-03-2013</td>
      <td align="center">1.9.0</td>
    </tr>
    <tr>
      <td align="center">1.7</td>
      <td>
      <ul>
        <li>added support for the&nbsp;<a href="#m8">WAGO
buscoupler 750-841</a> (2710 only)</li>
        <li>added a <a href="#func_if-init-temporal-filter">IfInitTemporalFilter</a>
and a <a href="#func_if-temporal-filter">IfTemporalFilter</a>
command to the formula module</li>
        <li>added a <a href="#func_root-square-add">RootSquareSum</a>
command to the formula module</li>
        <li>added a <a href="#func_save">Save</a>
command to the formula module</li>
        <li>added a <a href="#func_rotate-point">RotatePoint</a>
command to the formula module</li>
        <li>added the <a href="#m10">Gap Finder</a>
module</li>
        <li>added <a href="#m5">MathAll</a>, <a href="#m5">Clip</a>, <a href="#m5">ClipAll</a>,
          <a href="#m5">FillGaps</a> and <a href="#m5">FillGapsAll</a> filter types</li>
        <li><a href="#m5">Copy</a>, <a href="#m5">Math</a>, <a href="#m5">Clip</a>&nbsp;and
          <a href="#m5">FillGaps</a> type filters do
not
need
scratch space, the adjacent stripe is not used anymore</li>
      </ul>
      </td>
      <td align="center">v29-D2</td>
      <td align="center">v29-05</td>
      <td></td>
      <td align="center">Alpha-01-03-2012</td>
      <td align="center">1.8.4</td>
    </tr>
    <tr>
      <td align="center">1.6</td>
      <td>
      <ul>
        <li>added a <a href="#func_if-copy">IfCopy</a>
command to the formula module</li>
        <li>added modbus RTU slave&nbsp;including the <a href="#m9">GetHoldingRegisters</a> module (2810 only,
special customers only)</li>
      </ul>
      </td>
      <td align="center">v27-D2</td>
      <td align="center">v27-04</td>
      <td></td>
      <td align="center">Alpha-09-03-2010</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.5</td>
      <td>
      <ul>
        <li>added a <a href="#m6">comment</a>
module</li>
        <li>added support for <a href="#m8">WAGO
buscoupler 750-339</a></li>
      </ul>
      </td>
      <td align="center">v24-D2</td>
      <td align="center">v24-02</td>
      <td></td>
      <td align="center">Alpha-26-03-2009</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.4</td>
      <td>
      <ul>
        <li>added a rotation algorithm to the <a href="#m5">filter</a>
module</li>
        <li>added persistent memory with <a href="#func_if-store">if-store</a> and <a href="#func_if-recall">if-recall</a>
functions to the <a href="#m3">formula</a> module</li>
        <li>added an <a href="#func_if-call-module">if-call-command</a>
to the formula module</li>
        <li>added an outlier rejection algorithm to the<a href="#m2"> bead
finder</a> module</li>
      </ul>
      </td>
      <td align="center">v21-D2,<br>
special &nbsp;customers only</td>
      <td align="center">&nbsp;</td>
      <td></td>
      <td align="center">Alpha-10-07-2008</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.3</td>
      <td>
      <ul>
        <li>enhanced <a href="#m1">Cut</a>
module to support clipping of inside
points</li>
        <li>enhanced <a href="#m4Ex">GetOutput</a>
module to support 8 analogue
outputs</li>
        <li><a href="#m7">GetTimeStamp</a>
module</li>
      </ul>
      </td>
      <td align="center">v20-D2,<br>
special &nbsp;customers only</td>
      <td align="center">&nbsp;</td>
      <td></td>
      <td align="center">Alpha-18-10-2007</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.2</td>
      <td>
      <ul>
        <li>added calculation of the intersection point between
reference lines &nbsp;(<a href="#m2">bead finder</a>)<acronym></acronym></li>
      </ul>
      </td>
      <td align="center">v19-D2</td>
      <td align="center">&nbsp;</td>
      <td></td>
      <td align="center">Alpha-31-12-2006</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.1</td>
      <td>
      <ul>
        <li>added <a href="#m5">advanced profile
filtering</a></li>
        <li>added support for <a href="#func_mul-div">multiplication
and division</a> in post
processing</li>
        <li>added support for <a href="#func_write-serial">serial
output</a> of post processing
results<acronym></acronym></li>
      </ul>
      </td>
      <td align="center">v18-C2</td>
      <td align="center">&nbsp;</td>
      <td></td>
      <td align="center">Alpha-25-08-2006</td>
      <td align="center"></td>
    </tr>
    <tr>
      <td align="center">1.0</td>
      <td>
      <ul>
        <li>initial specification</li>
      </ul>
      </td>
      <td align="center">v16-C2</td>
      <td align="center">&nbsp;</td>
      <td></td>
      <td align="center">&nbsp;</td>
      <td align="center"></td>
    </tr>
  </tbody>
</table>
<h2><a name="general">General</a></h2>
<p>Post processing of profiles manipulates data on a profile by
profile basis. After basic processing, a queue of algorithms called
modules is executed.&nbsp;</p>
<p>All modules operate on one data set which is subdivided
into four stripes.
The stripes are aligned column by column.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>General Structure of Profile Data.</caption> <tbody>
    <tr>
      <th>&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
stripe 1<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</th>
      <th>stripe 2</th>
      <th>stripe 3</th>
      <th>stripe 4</th>
    </tr>
  </tbody>
</table>
<p>Each stripe can contain profile data of a single profile.
After standard processing (selection of one reflection, high
resolution, calibration)
the first stripe contains the measured profile and all other stripes
contain invalid data
(excepting the time stamp residing in the fourth stripe).
This is the recommended pre processing of profile data before post
processing.
All stripes may contain valid (and valuable) information
in special cases (processing of all reflections).</p>
<p>Each stripe consists of several sub stripes called fields.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>General Structure of stripes.</caption> <colgroup><col width="1%"><col width="7%"><col width="7%"><col width="7%"><col width="12%"><col width="12%"><col width="25%"><col width="25%"></colgroup><tbody>
    <tr>
      <th>&nbsp;<br>
&nbsp;<br>
&nbsp;<br>
r<br>
&nbsp;<br>
&nbsp;<br>
&nbsp;</th>
      <th>width</th>
      <th>height</th>
      <th>threshold</th>
      <th>position</th>
      <th>distance</th>
      <th>moment 0</th>
      <th>moment 1</th>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Description of Fields.</caption> <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td> 2</td>
      <td>r </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>10</td>
      <td>width </td>
      <td>width of reflection in pixels</td>
    </tr>
    <tr>
      <td>10</td>
      <td>height </td>
      <td>maximum intensity of reflection above the threshold</td>
    </tr>
    <tr>
      <td>10</td>
      <td>threshold </td>
      <td>actual threshold</td>
    </tr>
    <tr>
      <td>16</td>
      <td>position </td>
      <td>position co-ordinate (mostly called x)</td>
    </tr>
    <tr>
      <td>16</td>
      <td>distance </td>
      <td>distance co-ordinate (mostly called z)</td>
    </tr>
    <tr>
      <td>32</td>
      <td>moment 0</td>
      <td>integral intensity of reflection</td>
    </tr>
    <tr>
      <td>32</td>
      <td>moment 1</td>
      <td>first order moment</td>
    </tr>
  </tbody>
</table>
<p>Proper offset and stride must be used to extract field data
for whole profiles.
<br>
<em>Example:</em> Extracting the x-z-data of all points in
stripe 1 needs to extract every 16th quadlet
starting from the 2nd quadlet.</p>
<p>Each post processing module takes the number of its input
stripe and of its output stripe as arguments.
If the results are not a profile but a block of feature data, an
additional offset inside a stripe can be used
to concatenate several result blocks into a single stripe.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="param">Module Parameter Queue</a></h2>
<p>The post processing of profile data uses a queue of successive
blocks.
Each block describes one step of processing and may use the results of
a previous step as input.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Module Parameter Queue: General Structure.</caption>
  <tbody>
    <tr>
      <th>Header quadlet of block 1</th>
    </tr>
    <tr>
      <td>first parameter quadlet of block 1</td>
    </tr>
    <tr>
      <td>second parameter quadlet of block 1</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <td>last parameter quadlet of block 1</td>
    </tr>
    <tr>
      <th>Header quadlet of block 2</th>
    </tr>
    <tr>
      <td>first parameter quadlet of block 2</td>
    </tr>
    <tr>
      <td>second parameter quadlet of block 2</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <td>last parameter quadlet of block 2</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <th>Header quadlet for end of queue</th>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Module Parameter Queue: Structure of the Header
Quadlet.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td>module</td>
      <td>src</td>
      <td>dest</td>
      <td>rsv</td>
      <td>offset</td>
      <td>count</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Header Quadlet: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24</td>
      <td>module</td>
      <td>number of processing module</td>
    </tr>
    <tr>
      <td>23-22</td>
      <td>src</td>
      <td>source stripe: <tt>00<sub>b</sub></tt>=stripe
1, <tt>01<sub>b</sub></tt>=stripe 2, <tt>10<sub>b</sub></tt>=stripe
3, <tt>11<sub>b</sub></tt>=stripe 4</td>
    </tr>
    <tr>
      <td>21-20</td>
      <td>dest</td>
      <td>destination stripe: <tt>00<sub>b</sub></tt>=stripe
1, <tt>01<sub>b</sub></tt>=stripe 2, <tt>10<sub>b</sub></tt>=stripe
3, <tt>11<sub>b</sub></tt>=stripe 4</td>
    </tr>
    <tr>
      <td>19-18</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>17-8</td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>7-0 </td>
      <td>count </td>
      <td>quadlets count, including header quadlet</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="result">Module Result Queue</a></h2>
<p>If the result of a post processing module is not a complete
profile, results of several modules
should be concatenated into a single stripe using the offset field in
the header quadlet of the corresponding
block in the module parameter queue. The results reside only in the
position/distance fields of the target stripe.<br>
<em>Example:</em> If the destination stripe is stripe 4,
the result queue can be extracted by taking every 16th quadlet
starting from the 14th until the end of queue header is reached.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Module Result Queue: General Structure.</caption>
  <tbody>
    <tr>
      <th>Header quadlet of block 1</th>
    </tr>
    <tr>
      <td>first result quadlet of block 1</td>
    </tr>
    <tr>
      <td>second result quadlet of block 1</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <td>last result quadlet of block 1</td>
    </tr>
    <tr>
      <th>Header quadlet of block 2</th>
    </tr>
    <tr>
      <td>first result quadlet of block 2</td>
    </tr>
    <tr>
      <td>second result quadlet of block 2</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <td>last result quadlet of block 2</td>
    </tr>
    <tr>
      <td>...</td>
    </tr>
    <tr>
      <th>Header quadlet for end of queue</th>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Module Result Queue: Structure of the Header
Quadlet.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td>module</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>count</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The Header Quadlet: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24</td>
      <td>module </td>
      <td>number of processing module</td>
    </tr>
    <tr>
      <td>23-22</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>21-20</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>19-16</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-8 </td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>7-0 </td>
      <td>count </td>
      <td>quadlets count, including header quadlet</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="pan">Accessing the Module Parameter
Queue with the PAN Register</a></h2>
<p>The PAN-register defined in the <a href="http://www.1394ta.org/">
HDC 1394-based Digital Camera Specification Version 1.30 (July 25, 2000)</a>
can be used to write to the module parameter queue. The actual access
to the queue
needs a sequence of successive writes to the PAN-register.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Value field of the PAN-Register.</caption> <colgroup><col width="25%"><col width="8%"><col width="66%"></colgroup>
  <tbody>
    <tr align="center">
      <td>command</td>
      <td>toggle</td>
      <td>data</td>
    </tr>
  </tbody>
</table>
<p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The PAN-Register: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>11-9</td>
      <td>command</td>
      <td>command</td>
    </tr>
    <tr>
      <td> 8-8</td>
      <td>toggle </td>
      <td>toggle bit, must toggle for successive writes</td>
    </tr>
    <tr>
      <td> 7-0</td>
      <td>data </td>
      <td>data byte</td>
    </tr>
  </tbody>
</table>
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>The PAN-Register: Commands.</caption> <thead>
  <tr>
    <th>Command</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>0</td>
      <td>Reset the write pointer to the beginning of the
parameter queue, data field must be 0</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Write one byte (the data field) at the current pointer
position and move the pointer 1 byte position towards the end of the
queue</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Move the pointer towards the end of the queue, the data
field contains the number of byte positions to move, 0 means 256</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Move the pointer towards the beginning of the queue,
the data field contains the number of byte positions to move, 0 means
256</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Initialise internal memories. The <a href="#m3">formula
module</a> has registers, a persistent memory block and the
filter block, which this command fills with zeros.&nbsp;</td>
    </tr>
  </tbody>
</table>
<br>
<strong>Remarks:</strong>
<ul>
  <li>The toggle bit ensures that every write access to the
PAN-register results in only one access to the queue, also if the
actual access on the firewire bus is repeated because of lost packets
or because the underlying driver submits several writes. To
synchronize,
the
first two writes to the PAN register should always be <tt>000</tt>
followed by <tt>256</tt>. </li>
  <li>The byte ordering inside of quadlets is <em>Most
Significant First</em>. </li>
  <li>To prevent race conditions between the byte access to the
parameter queue and the post processing itself the processing is
suspended as long as the write pointer does not point to the beginning
of the queue. Therefore, the last write should always be <tt>000</tt>
(or <tt>256</tt> depending on the state of the toggle bit).</li>
</ul>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m0">Module 0: End of Queue</a></h2>
<p>This special module indicates the end of the queue.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>End of Queue: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>0</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>End of Queue: Module Result Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>0</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>0</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>End of Queue: Description of Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>&nbsp;23-9</td>
      <td>rsv</td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m1">Module 1: Cut</a></h2>
<p>The cut module provides 2D-clipping. It marks points that lie
outside a specific rectangular window as invalid.
The ordering of points remains unchanged. The module takes one profile
as input and
outputs the clipped profile.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Cut: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>1</td>
      <td>src</td>
      <td>dest</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>3</td>
    </tr>
    <tr align="center">
      <td colspan="4">MinX</td>
      <td colspan="2">MinZ</td>
    </tr>
    <tr align="center">
      <td colspan="4">MaxX</td>
      <td colspan="2">MaxZ</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Cut: Module Parameter Block (extended).</caption>
  <colgroup><col width="3%"><col width="22%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="2">1</td>
      <td>src</td>
      <td>dest</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>4</td>
    </tr>
    <tr align="center">
      <td colspan="5">MinX</td>
      <td colspan="2">MinZ</td>
    </tr>
    <tr align="center">
      <td colspan="5">MaxX</td>
      <td colspan="2">MaxZ</td>
    </tr>
    <tr align="center">
      <td>iv</td>
      <td colspan="6">reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Cut: Description of Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22 </td>
      <td>src </td>
      <td>source stripe</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest</td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>MinX</td>
      <td>lower boundary of the position co-ordinate</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>MinZ</td>
      <td>lower boundary of the distance co-ordinate</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>MaxX</td>
      <td>upper boundary of the position co-ordinate</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>MaxZ</td>
      <td>upper boundary of the distance co-ordinate</td>
    </tr>
    <tr>
      <td>31</td>
      <td>iv</td>
      <td>Invert the clipping, mark all points inside the
&nbsp;window as invalid</td>
    </tr>
  </tbody>
</table>
<p><em>All boundaries must be scaled to 16bit values using
the same scaling as for
profile points.</em></p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m2">Module 2: Bead Finder</a></h2>
<p>The bead finder module extracts characteristics of a bead or a
similar geometrical feature.
Its algorithm subdivides into four steps:
</p>
<ol>
  <li>detection of anchor point </li>
  <li>detection of reference lines </li>
  <li>detection of bead </li>
  <li>calculate characteristics of bead</li>
</ol>
Step 2. may involve an outlier rejection algorithm. If the outlier
rejection threshold is greater than 0 then&nbsp;approximate
reference
lines will be fitted to all points in the reference ranges. The final
reference lines fit only to those points&nbsp;having
a&nbsp;distance
from the approximate lines smaller than the rejection threshold. <br>
<br>
See the data sheet or manual for the scan<acronym>CONTROL</acronym>&nbsp;2810
(German x9750149.pdf, English x9751149.pdf) for a detailed description.<br>
<em>The bead finder algorithm uses the 3rd stripe as scratch
space. Do not use th 3rd stripe as source or destination.<br>
<br>
</em>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Bead Finder: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="7%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="7%"><col width="3%"><col width="6%"><col width="6%"><col width="3%"><col width="7%"></colgroup>
  <tbody>
    <tr align="center">
      <td>2</td>
      <td>src</td>
      <td>dest</td>
      <td colspan="1">rsv</td>
      <td colspan="9">offset</td>
      <td colspan="5">10</td>
    </tr>
    <tr align="center">
      <td colspan="4">rsv</td>
      <td>et</td>
      <td>cg</td>
      <td>fg</td>
      <td>ip</td>
      <td>ns</td>
      <td>tr</td>
      <td>ax</td>
      <td>hi</td>
      <td>bsearch</td>
      <td>f</td>
      <td>bref</td>
      <td>ref</td>
      <td>dt</td>
      <td>anchor</td>
    </tr>
    <tr align="center">
      <td colspan="6">offset of the anchor point (signed)</td>
      <td colspan="12">outlier rejection threshold
(unsigned)</td>
    </tr>
    <tr align="center">
      <td colspan="18">start of the left reference range
(signed)</td>
    </tr>
    <tr align="center">
      <td colspan="18">start of the right reference range
(signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">width of the left reference range
(unsigned)</td>
      <td colspan="12">width of the right reference range
(unsigned)</td>
    </tr>
    <tr align="center">
      <td colspan="18">start of the bead range (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">width of the bead range (unsigned)</td>
      <td colspan="2">stripe</td>
      <td colspan="10">quadlett offset</td>
    </tr>
    <tr align="center">
      <td colspan="18">minimum width of the bead (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">left threshold (signed)</td>
      <td colspan="12">right threshold (signed)</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Bead Finder: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
    <th>used in step</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22 </td>
      <td>src </td>
      <td>source stripe</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td>17-17</td>
      <td>et</td>
      <td>external tracing of ranges:<br>
      <tt> 0<sub>b</sub></tt>=static, no
external tracing<br>
      <tt> 1<sub>b</sub></tt>=dynamic tracing,
the anchor point is read from previous result using stripe and quadlett
offset fields,&nbsp;ranges are relative to the this point</td>
      <td></td>
    </tr>
    <tr>
      <td>16-16</td>
      <td>cg</td>
      <td>calculate center of gravity and distance to origin for
the reference lines:<br>
      <tt> 0<sub>b</sub></tt>=do not calculate
center
of gravity and distance to origin<br>
      <tt> 1<sub>b</sub></tt>=calculate center
of gravity and distance to origin, module result block is at least 24
quadletts long<br>
      </td>
      <td>2</td>
    </tr>
    <tr>
      <td>15-15</td>
      <td>fg</td>
      <td>ignore points having z=1 or z=65535 (sensor units)
during
calculation of references, &nbsp;intended for use in conjunction
with
filter modules of <a href="#m5">FillGaps</a> and <a href="#m5">FillGapsAll</a> filter types<span style="text-decoration: underline;"></span></td>
      <td>2</td>
    </tr>
    <tr>
      <td>14-14</td>
      <td>ip</td>
      <td>calculate intersection point for reference lines:<br>
      <tt> 0<sub>b</sub></tt>=do not calculate
intersection point<br>
      <tt> 1<sub>b</sub></tt>=calculate
intersection point, module result block is at least 20 quadletts long<br>
A valid intersection point results only in case of two independent
reference levels. </td>
      <td>2</td>
    </tr>
    <tr>
      <td>13-13 </td>
      <td>ns </td>
      <td>suppress search for anchor points:<br>
      <tt> 0<sub>b</sub></tt>=search for anchor
points<br>
      <tt> 1<sub>b</sub></tt>=do not search for
anchor points</td>
      <td>1</td>
    </tr>
    <tr>
      <td>12-12 </td>
      <td>tr </td>
      <td>detection of bead edge:<br>
      <tt>0<sub>b</sub></tt>=edge must have a
transition at the threshold level<br>
      <tt>1<sub>b</sub></tt>=no transition
required</td>
      <td>3</td>
    </tr>
    <tr>
      <td>11-11 </td>
      <td>ax </td>
      <td>expansion of bead area to selected reference line:<br>
      <tt>0<sub>b</sub></tt>=no expansion
calculate area only from the bead points<br>
      <tt>1<sub>b</sub></tt>=expand bead area
down to the selected reference line</td>
      <td>4 </td>
    </tr>
    <tr>
      <td>10-10 </td>
      <td>hi </td>
      <td>resolution of bead width:<br>
      <tt>0<sub>b</sub></tt>=low resolution<br>
      <tt>1<sub>b</sub></tt>=high resolution</td>
      <td>4</td>
    </tr>
    <tr>
      <td>9-8 </td>
      <td>bsearch</td>
      <td>direction of bead search:<br>
      <tt>00<sub>b</sub></tt>=search only from
left<br>
      <tt>01<sub>b</sub></tt>=search only from
right<br>
      <tt>10<sub>b</sub></tt>=search from left
and right<br>
      <tt>11<sub>b</sub></tt>=reserved</td>
      <td>3</td>
    </tr>
    <tr>
      <td>7-7 </td>
      <td>f </td>
      <td>flip (search a positive or negative bead):<br>
      <tt> 0<sub>b</sub></tt>=search for a
positive bead, a bump between reference line and the sensor<br>
      <tt> 1<sub>b</sub></tt>=search for a
negative bead, a groove below reference line as seen from the sensor</td>
      <td>3</td>
    </tr>
    <tr>
      <td>6-5 </td>
      <td>bref </td>
      <td>reference for bead search and bead characteristics:<br>
      <tt>00<sub>b</sub></tt>=two different
reference levels and left reference orientation<br>
      <tt>01<sub>b</sub></tt>=two different
reference levels and right reference orientation<br>
      <tt>10<sub>b</sub></tt>=only left
reference
level and left orientation<br>
      <tt>11<sub>b</sub></tt>=only right
reference
level and right orientation</td>
      <td>3+4</td>
    </tr>
    <tr>
      <td>4-3 </td>
      <td>ref </td>
      <td>reference&nbsp;finder:<br>
      <tt>00<sub>b</sub></tt>=only one
reference
level and orientation<br>
      <tt>01<sub>b</sub></tt>=two reference
levels
with different orientations<br>
      <tt>10<sub>b</sub></tt>=two reference
levels
with the same orientation<br>
      <tt>11<sub>b</sub></tt>=reserved</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2-2 </td>
      <td>dt </td>
      <td>dynamic tracing of ranges:<br>
      <tt> 0<sub>b</sub></tt>=static, no
tracing, ranges are relative to the global origin (static anchor point)<br>
      <tt> 1<sub>b</sub></tt>=dynamic tracing,
ranges are relative to the selected anchor point</td>
      <td>2+3</td>
    </tr>
    <tr>
      <td>1-0 </td>
      <td>anchor </td>
      <td>selection of dynamic anchor point:<br>
      <tt>00<sub>b</sub></tt>=minimum distance<br>
      <tt>01<sub>b</sub></tt>=maximum distance<br>
      <tt>10<sub>b</sub></tt>=leftmost valid
point<br>
      <tt>11<sub>b</sub></tt>=rightmost valid
point</td>
      <td>1</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>offset of the anchor (signed) </td>
      <td>global offset for all ranges, counts from the anchor
point used</td>
      <td>2+3</td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>outlier rejection threshold (unsigned)</td>
      <td>points with a larger distance from the reference line
are treated as outliers and are not considered,<br>
a threshold of 0
disables the outlier detection algorithm</td>
      <td>2</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>start of the left reference range (signed) </td>
      <td rowspan="2">starts of the two reference ranges</td>
      <td rowspan="2">2</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>start of the right reference range (signed) </td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>width of the left reference range (unsigned) </td>
      <td rowspan="2">widths of the two reference ranges</td>
      <td rowspan="2">2</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>width of the right reference range (unsigned)</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>start of the bead range (signed) </td>
      <td>start of the bead range</td>
      <td>3</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>width of the bead range (unsigned) </td>
      <td>width of the bead range</td>
      <td>3</td>
    </tr>
    <tr>
      <td>15-14</td>
      <td>stripe</td>
      <td>source stripe for the quadlett offset</td>
      <td></td>
    </tr>
    <tr>
      <td>13-0</td>
      <td>quadlett offset</td>
      <td>quadlett offset for external tracing</td>
      <td></td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>minimum width of the bead (signed) </td>
      <td>minimal width of the bead, smaller beads will be
suppressed</td>
      <td>3</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>left threshold (signed) </td>
      <td rowspan="2">threshold for bead recognition</td>
      <td rowspan="2">3</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>right threshold (signed) </td>
    </tr>
  </tbody>
</table>
<p><em>All ranges, offsets and thresholds must be scaled to
16bit values using only the scaling factor for
profile points. Note that the range offset and the two thresholds are
signed.</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Bead Finder: Module Result Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>2</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>19 (20,24) <sup>(*)</sup></td>
    </tr>
    <tr align="center">
      <td colspan="4">anchor point x</td>
      <td colspan="2">anchor point z</td>
    </tr>
    <tr align="center">
      <td colspan="4">left reference points count</td>
      <td colspan="2">right reference points count</td>
    </tr>
    <tr align="center">
      <td colspan="4">left reference orientation (signed)</td>
      <td colspan="2">right reference orientation (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">left reference level (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">right reference level (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="4">left reference standard deviation
(unsigned)</td>
      <td colspan="2">right reference standard deviation
(unsigned)</td>
    </tr>
    <tr align="center">
      <td colspan="4">bead left position x</td>
      <td colspan="2">bead left position z</td>
    </tr>
    <tr align="center">
      <td colspan="4">bead top position x</td>
      <td colspan="2">bead top position z</td>
    </tr>
    <tr align="center">
      <td colspan="4">bead right position x</td>
      <td colspan="2">bead right position z</td>
    </tr>
    <tr align="center">
      <td colspan="6">width (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="6">height (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="4">reserved</td>
      <td colspan="2">bead points count</td>
    </tr>
    <tr align="center">
      <td colspan="6">area (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="4">computation time</td>
      <td colspan="2">error code</td>
    </tr>
    <tr align="center">
      <td colspan="4">point of minimum distance x</td>
      <td colspan="2">point of minimum distance z</td>
    </tr>
    <tr align="center">
      <td colspan="4">point of maximum distance x</td>
      <td colspan="2">point of maximum distance z</td>
    </tr>
    <tr align="center">
      <td colspan="4">leftmost valid point x</td>
      <td colspan="2">leftmost valid point z</td>
    </tr>
    <tr align="center">
      <td colspan="4">rightmost valid point x</td>
      <td colspan="2">rightmost valid point z</td>
    </tr>
    <tr align="center">
      <td colspan="4">intersection point x <sup>(*)</sup></td>
      <td colspan="2">intersection point z <sup>(*)</sup></td>
    </tr>
    <tr align="center">
      <td colspan="4">left center of gravity x <sup>(*)</sup></td>
      <td colspan="2">left center of gravity z <sup>(*)</sup></td>
    </tr>
    <tr align="center">
      <td colspan="4">right center of gravity x <sup>(*)</sup></td>
      <td colspan="2">right center of gravity z <sup>(*)</sup></td>
    </tr>
    <tr align="center">
      <td colspan="6">left distance to origin (signed) <sup>(*)</sup></td>
    </tr>
    <tr align="center">
      <td colspan="6">right distance to origin (signed) <sup>(*)</sup></td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Bead Finder: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-16</td>
      <td>anchor point x </td>
      <td rowspan="2">selected anchor point</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>anchor point z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>left reference points count </td>
      <td rowspan="2">number of valid points inside the
reference ranges</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>right reference points count </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>left reference orientation </td>
      <td rowspan="2">reference&nbsp;angle left/right,
      <tt>0.01°</tt>
units</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>right reference orientation </td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>left reference level </td>
      <td rowspan="2">reference&nbsp;level left/right</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>right reference level </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>left reference standard deviation </td>
      <td rowspan="2">standard deviation left/right</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>right reference standard deviation </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>bead left position x </td>
      <td rowspan="2">coordinates of the left edge of the
bead</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>bead left position z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>bead top position x </td>
      <td rowspan="2">coordinates of the top of the bead</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>bead top position z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>bead right position x </td>
      <td rowspan="2">coordinates of the right edge of the
bead</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>bead right position z </td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>width </td>
      <td>width of the bead</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>height </td>
      <td>height of the bead</td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>reserved </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>bead points count </td>
      <td>number of valid points inside the bead range</td>
    </tr>
    <tr>
      <td>31-0 </td>
      <td>area </td>
      <td>area of the bead</td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>computation time </td>
      <td>computation time used, unit <tt>1&#956;s</tt></td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>error code </td>
      <td> 0 = no error<br>
      <br>
10 = no valid points<br>
11 = invalid external anchor point<br>
18 = reserved<br>
      <br>
20 = no points inside of reference ranges<br>
21 = no intersection point, reference lines parallel<br>
22 = intersection point out of range<br>
28 = invalid selection of reference finder (ref)<br>
29 = arithmetic error during calculation of reference parameters<br>
      <br>
30 = no points inside of bead range<br>
31 = no bead found<br>
32 = bead width is lower than the minimum bead width<br>
38 = invalid selection of bead search direction (bsearch)<br>
39 = arithmetic error during bead search </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>point of minimum distance x </td>
      <td rowspan="14">characteristic points</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>point of minimum distance z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>point of maximum distance x </td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>point of maximum distance z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>leftmost valid point x </td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>leftmost valid point z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>rightmost valid point x </td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>rightmost valid point z </td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>intersection point x <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>intersection point z <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>left center of gravity x <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>left center of gravity z <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>right center of gravity x <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>right center of gravity z <sup>(*)</sup></td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>left distance to origin (signed)&nbsp;<sup>(*)</sup></td>
      <td rowspan="2">distance to the coordinate origin</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>right&nbsp;distance to origin (signed) <sup>(*)</sup></td>
    </tr>
  </tbody>
</table>
<p><em>The anchor point, reference levels, standard
deviations and co-ordinates of the bead must be scaled
from 16bit/32bit values using the same scaling as for profile points.
The area scales with the scaling factor squared.</em></p>
<p> <sup>(*) </sup>Backward compatibility: The
length of the result block depends on the settings for the calculation
of the intersection point and/or calculation of the center of gravity
points. If both bits are unset then the result block
will have only 19 quadlets as in previous versions of the bead finder
module.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m3">Module 3: Formula</a></h2>
<p>The formula module offers a flexible way to process the
results from other modules.
It provides 32 internal registers (32bit) and a set of function
primitives to load, write,
add, subtract, shift and compare these registers. Each function
primitive occupies one
quadlet in the module parameter block. Depending on the number of
primitive operations
necessary to complete the actual task the parameter block has a
variable length.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Formula: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="12%"><col width="6%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="3%"><col width="6%"><col width="6%"><col width="3%"><col width="6%"></colgroup>
  <tbody>
    <tr align="center">
      <td>3</td>
      <td>src</td>
      <td>dest</td>
      <td>rsv</td>
      <td colspan="6">rsv</td>
      <td colspan="5">length</td>
    </tr>
    <tr align="center">
      <td colspan="15">first primitive operation</td>
    </tr>
    <tr align="center">
      <td colspan="15">second primitive operation</td>
    </tr>
    <tr align="center">
      <td colspan="15">...</td>
    </tr>
    <tr align="center">
      <td colspan="15">last primitive operation</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Formula: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22 </td>
      <td>src </td>
      <td>source stripe, used by <a href="#func_load">load</a>
and<a href="#func_load-write"> load-write</a></td>
    </tr>
    <tr>
      <td>21.20</td>
      <td>dest</td>
      <td>destination stripe, used by <a href="#func_save">save</a></td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td> 7- 0 </td>
      <td>length </td>
      <td>length of the parameter block, number of primitive
operations + 1</td>
    </tr>
  </tbody>
</table>
<p>The formula module provides 32 logical output channels
(16bit). The mapping of the logical channels to the physical ports is
fixed but depends on the used hardware.&nbsp;</p>
<table id="portmapping" frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Formula: Port mapping of the output channels.</caption>
  <thead> <tr>
    <th>Logical channel number</th>
    <th>scan<acronym>CONTROL</acronym>&nbsp;2810
internal ports</th>
    <th>scan<acronym>CONTROL</acronym>&nbsp;2810
output unit</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>0</td>
      <td>first analogue output</td>
      <td>first analogue module or first port of first
analogue module</td>
    </tr>
    <tr>
      <td>1</td>
      <td>second analogue output</td>
      <td>second analogue module or second port of first
analogue module</td>
    </tr>
    <tr>
      <td>2</td>
      <td>not available</td>
      <td>(analogue ports are enumerated sequentially as they
are installed)</td>
    </tr>
    <tr>
      <td>3..6</td>
      <td>not available</td>
      <td>..</td>
    </tr>
    <tr>
      <td>7</td>
      <td>not available</td>
      <td>last enumerated analogue port (all in all 8 supported
ports)</td>
    </tr>
    <tr>
      <td>8</td>
      <td>output port 1</td>
      <td>first digital module or first port of first digital
module</td>
    </tr>
    <tr>
      <td>9</td>
      <td>output port 2</td>
      <td>second digital module or second port of first digital
module</td>
    </tr>
    <tr>
      <td>10</td>
      <td>output port 3</td>
      <td>(digital ports are enumerated sequentially as they
are installed)</td>
    </tr>
    <tr>
      <td>11..30</td>
      <td>not available</td>
      <td>..</td>
    </tr>
    <tr>
      <td>31</td>
      <td>not available</td>
      <td>last enumerated digital port (all in all 24 supported
ports)</td>
    </tr>
  </tbody>
</table>
<p><a name="func_example">The example below
illustrates the concept. The formula module loads the two reference
orientations
calculated by a previous bead finder module, calculates the angular
deviation and outputs
the result to the analogue port.</a></p>
<table id="Table1" frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Formula: Module parameter block (example).</caption>
  <thead> <tr>
    <th>Position</th>
    <th>Parameter</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>1</td>
      <td>0x03C00006</td>
      <td>header of the formula module</td>
    </tr>
    <tr>
      <td>2</td>
      <td>0x01004003</td>
      <td>loads the left signed direction into register 0 with no
shift</td>
    </tr>
    <tr>
      <td>3</td>
      <td>0x01085003</td>
      <td>loads the right signed direction into register 1 with a
shift of 16 for the lower 16 bits</td>
    </tr>
    <tr>
      <td>4</td>
      <td>0x06006001</td>
      <td>subtract register 0 and 1 as signed values, puts the
result in register 0</td>
    </tr>
    <tr>
      <td>5</td>
      <td>0x03080001</td>
      <td>loads a constant 1 into register 1</td>
    </tr>
    <tr>
      <td>6</td>
      <td>0x05010001</td>
      <td>if register 1 &gt; 0 writes register 0 into the
output channel 0, additional toggle the sign bit for a symmetric output</td>
    </tr>
  </tbody>
</table>
<p>The following function primitives are available:</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Formula: List of function primitives.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td><a href="#func_load"> func(load) = 1</a></td>
      <td>reg1</td>
      <td colspan="2">offset</td>
      <td>dw</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
    <tr align="center">
      <td><a href="#func_load-write">func(load-write)
= 2</a></td>
      <td>out </td>
      <td colspan="2">offset</td>
      <td>ts</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
    <tr align="center">
      <td><a href="#func_load-const">func(load-const)
= 3</a></td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>lb</td>
      <td colspan="9">const value</td>
    </tr>
    <tr align="center">
      <td><a href="#func_compare"> func(compare) = 4</a></td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>s</td>
      <td>lt</td>
      <td>gt</td>
      <td>eq</td>
      <td>u</td>
      <td colspan="2">link</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_if-write"> func(if-write) =
5</a></td>
      <td>out </td>
      <td colspan="2">rsv</td>
      <td>ts</td>
      <td colspan="6">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_add"> func(add) = 6</a></td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>sub</td>
      <td colspan="3">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_shift"> func(shift) = 7</a></td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td>rsv</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_write-serial">func(if-write-serial)
= 8</a></td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>dw</td>
      <td>os</td>
      <td>s</td>
      <td colspan="4">fill</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_mul-div">func(multiply)
= 9</a></td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>div</td>
      <td>o32</td>
      <td>r32</td>
      <td>rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr>
      <td align="center"><a href="#func_if-store">func(if-store)
= 10</a></td>
      <td align="center">address</td>
      <td colspan="9" align="center">rsv</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
    <tr>
      <td align="center"><a href="#func_if-recall">func(if-recall)
= 11</a></td>
      <td align="center">address</td>
      <td colspan="9" align="center">rsv</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
    <tr>
      <td align="center"><a href="#func_if-call-module">func(if-call-module)
= 12</a></td>
      <td align="center">address</td>
      <td colspan="9" align="center">rsv</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">rsv</td>
    </tr>
    <tr>
      <td align="center"><a href="#func_if-copy">func(if-copy)
= 13</a></td>
      <td align="center">reg1</td>
      <td colspan="4" align="center">rsv</td>
      <td colspan="5" align="center">reg4</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_root-square-add">func(root-square-add)
= 14</a></td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>sub</td>
      <td colspan="3">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td><a href="#func_save"> func(save) = 15</a></td>
      <td>reg1</td>
      <td colspan="2">offset</td>
      <td>dw</td>
      <td colspan="2">rsv</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
    <tr align="center">
      <td align="center"><a href="#func_rotate-point">func(rotate-point)
= 16</a></td>
      <td>reg1</td>
      <td colspan="4">rsv</td>
      <td colspan="5" align="center">reg4</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
    <tr align="center">
      <td align="center"><a href="#func_if-init-temporal-filter">func(if-init-temporal-filter)
= 17</a></td>
      <td>size</td>
      <td>f</td>
      <td>c</td>
      <td>dw </td>
      <td colspan="3">rsv</td>
      <td colspan="3">type</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
    <tr align="center">
      <td align="center"><a href="#func_if-temporal-filter">func(if-temporal-filter)
= 18</a></td>
      <td>reg1</td>
      <td colspan="4">rsv</td>
      <td colspan="5" align="center">reg4</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
    <tr align="center">
      <td align="center"><a href="#func_project-point">func(project-point)
= 19</a></td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>rl</td>
      <td colspan="5" align="center">reg4</td>
      <td colspan="2" align="center">reg2</td>
      <td align="center">reg3</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_load">Formula: Function load</a></h3>
<p>Loads a value from the result queue into a register. Loads
entire 32 bit or the upper 16bit with shift.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(load) = 1</td>
      <td>reg1</td>
      <td colspan="2">offset</td>
      <td>dw</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load: Description of Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 1</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>18-17</td>
      <td>offset</td>
      <td>offset bits 9-8</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>dw </td>
      <td>data width:<br>
      <tt>0<sub>b</sub></tt>=loads a 16 bit
value in the upper 16 bit (applies shift and saturation)<br>
      <tt>1<sub>b</sub></tt>=loads a 32 bit
value (ignores shift and saturation)</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode after shifting: <tt>0<sub>b</sub></tt>=no
saturation, <tt>1<sub>b</sub></tt>=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: <tt>0<sub>b</sub></tt>=unsigned,
      <tt>1<sub>b</sub></tt>=signed</td>
    </tr>
    <tr>
      <td>13-8 </td>
      <td>shift </td>
      <td>distance of shift (-32...31)</td>
    </tr>
    <tr>
      <td>7-0 </td>
      <td>offset </td>
      <td>quadlet offset inside of the source stripe</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_load-write">Formula: Function
load-write</a></h3>
<p>Writes a value from the result queue directly to an output.
Outputs are only 16 bit wide, so the loaded value must be shifted into
the upper 16 bits.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load-write: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(load-write) = 2</td>
      <td>out </td>
      <td colspan="2">offset</td>
      <td>ts</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load-write: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 2</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>out </td>
      <td>output channel:
      <ol start="0">
        <li>analogue output port 1 </li>
        <li>analogue output port 2</li>
      </ol>
      <ol start="8">
        <li>digital output port 1 </li>
        <li>digital output port 2 </li>
        <li>digital output port 3</li>
      </ol>
      </td>
    </tr>
    <tr>
      <td>18-17</td>
      <td>offset</td>
      <td>offset bits 9-8</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>ts </td>
      <td>toggle sign bit</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode after shifting: <tt>0<sub>b</sub></tt>=no
saturation, <tt>1<sub>b</sub></tt>=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: <tt>0<sub>b</sub></tt>=unsigned,
      <tt>1<sub>b</sub></tt>=signed</td>
    </tr>
    <tr>
      <td>13-8 </td>
      <td>shift </td>
      <td>shift distance (-32...31)</td>
    </tr>
    <tr>
      <td>7-0 </td>
      <td>offset </td>
      <td>quadlet offset inside of the source stripe</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_load-const">Formula: Function
load-const</a></h3>
<p>Loads a given constant value into a register. Loads only 16bit
at once.
To initialise 32bit set the upper 16bit first, then the lower 16bit.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load-const: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(load-const) = 3</td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>lb</td>
      <td colspan="9">const value</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function load-const: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...) </td>
      <td>called function = 3</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>lb </td>
      <td>destination bits:<br>
      <tt>0<sub>b</sub></tt>=load the upper
16bits and clear the lower 16bits<br>
      <tt>1<sub>b</sub></tt>=load the lower
16bits</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>const value</td>
      <td>constant</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_compare">Formula: Function compare</a></h3>
<p>Compares two registers and stores the result in the
destination register.
First, the comparison yields an intermediate result according to the
lt, gt and eq fields (disjunction).
Second, the intermediate result overwrites or updates the destination
register.
Sets or updates the upper 16bits with 0 or 1.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function compare: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(compare) = 4</td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>s</td>
      <td>lt</td>
      <td>gt</td>
      <td>eq</td>
      <td>u</td>
      <td colspan="2">link</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function compare: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 4</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>s </td>
      <td>data type: 0b=unsigned, 1b=signed&nbsp;</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>lt </td>
      <td>compare as lower than</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>gt </td>
      <td>compare as greater than</td>
    </tr>
    <tr>
      <td>13-13 </td>
      <td>eq </td>
      <td>compare as equal</td>
    </tr>
    <tr>
      <td>12-12 </td>
      <td>u </td>
      <td>set or update:<br>
      <tt>0<sub>b</sub></tt>=overwrite the
destination register<br>
      <tt>1<sub>b</sub></tt>=update the
destination register according to the link field</td>
    </tr>
    <tr>
      <td>11-10 </td>
      <td>link </td>
      <td>update operation:<br>
      <tt>00<sub>b</sub></tt>=and<br>
      <tt>01<sub>b</sub></tt>=or<br>
      <tt>10<sub>b</sub></tt>=xor<br>
      <tt>11<sub>b</sub></tt>=cmp</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>first operand (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>second operand (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-write">Formula: Function
if-write</a></h3>
<p>Writes a value from source register to an output only if the
flag register does not equal to zero.
<br>
<em>There is no write-always function.
Loading 1 into the upper 16bits of the flag register results in an
unconditional write
(compare <a href="#func_example">example</a> above).</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-write: Quadlet.</caption><tbody>
    <tr align="center">
      <td>func(if-write) = 5</td>
      <td>out </td>
      <td colspan="2">rsv</td>
      <td>ts</td>
      <td colspan="6">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-write: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 5</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>out </td>
      <td>output channel:
      <ol start="0">
        <li>analogue&nbsp;output port 1</li>
        <li>analogue&nbsp;output port 2</li>
      </ol>
      <ol start="8">
        <li>digital output port 1 </li>
        <li>digital output port 2 </li>
        <li>digital output port 3</li>
      </ol>
      </td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>ts </td>
      <td>toggle sign bit</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_add">Formula: Function add</a></h3>
<p>Adds or subtracts two registers.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function add: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(add) = 6</td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>sub</td>
      <td colspan="3">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function add: Description of Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 6</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode: <tt>0<sub>b</sub></tt>=no
saturation, <tt>1<sub>b</sub></tt>=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: 0b=unsigned, 1b=signed</td>
    </tr>
    <tr>
      <td>13-13 </td>
      <td>sub </td>
      <td>operation: <tt>0<sub>b</sub></tt>=addition,
      <tt>1<sub>b</sub></tt>=subtraction</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>first operand (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>second operand (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_shift">Formula: Function shift</a></h3>
<p>Shifts a register stores the result in the destination
register.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function shift: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(shift) = 7</td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td colspan="5">shift</td>
      <td>rsv</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function shift: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 7</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode: 0b=no saturation, 1b=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: 0b=unsigned, 1b=signed</td>
    </tr>
    <tr>
      <td>13-8 </td>
      <td>shift </td>
      <td>shift distance (-32...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_write-serial">Formula: Function
if-write-serial</a></h3>
<p>Writes a value from a source register to the serial output
only
if the flag register does not equal to zero. The&nbsp;value is
output as decimal integer with optional padding on the left and an
optional trailing string of up to 4 characters.&nbsp;Using several
if-write-serial primitives in one formula module builds
longer&nbsp;strings with several values. </p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function write-serial: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td><a href="#func_write-serial">func(if-write-serial)
= 8</a></td>
      <td>reg1</td>
      <td colspan="2">rsv</td>
      <td>dw</td>
      <td>os</td>
      <td>s</td>
      <td colspan="4">fill</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-write-serial: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 8</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>register with the trailing string, contains up to 4
characters in the upper bytes, the most significant byte is sent first.
If os=<tt>0<sub>b</sub></tt> then the string is
null terminated.
If os=<tt>1<sub>b</sub></tt> then the fill
field determines the number of characters to be sent:
0 means null terminated, 1 means 1 byte (the most significant), 2 means
2 bytes and so on. </td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>dw </td>
      <td>data width:<br>
      <tt>0<sub>b</sub></tt>=writes a 16 bit
value<br>
      <tt>1<sub>b</sub></tt>=writes a 32 bit
value</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>os </td>
      <td><tt>1<sub>b</sub></tt>=output
trailing string only, <tt>0<sub>b</sub></tt>=register
and trailing string</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: <tt>0<sub>b</sub></tt>=unsigned,
      <tt>1<sub>b</sub></tt>=signed</td>
    </tr>
    <tr>
      <td>13-10 </td>
      <td>fill </td>
      <td>minimum field size (0..11), &nbsp;values are padded
on the left with spaces to allow right justified columns&nbsp;</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register (0...31)</td>
    </tr>
  </tbody>
</table>
<br>
The output string of one formula module must not be longer than 80
characters. The string is send at the end of the module's execution.<br>
If the string of a previously executed formula module is still being
transmitted the newly built string is discarded.<br>
<h3><a name="func_mul-div">Formula: Function multiply</a></h3>
<p>Multiplies or divides two registers.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function multiply: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(multiply) = 9</td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>div</td>
      <td>o32</td>
      <td>r32</td>
      <td>rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function mul-div: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 9</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode: <tt>0<sub>b</sub></tt>=no
saturation, <tt>1<sub>b</sub></tt>=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: <tt>0<sub>b</sub></tt>=unsigned,
      <tt>1<sub>b</sub></tt>=signed</td>
    </tr>
    <tr>
      <td>13-13 </td>
      <td>div </td>
      <td>operation: <tt>0<sub>b</sub></tt>=multiplication,
      <tt>1<sub>b</sub></tt>=division</td>
    </tr>
    <tr>
      <td>12-12 </td>
      <td>o32 </td>
      <td>data width:&nbsp;<tt>0<sub>b</sub></tt>=16
bit, <tt>1<sub>b</sub></tt>=32 bit</td>
    </tr>
    <tr>
      <td>11-11 </td>
      <td>r32 </td>
      <td>result data width: <tt>0<sub>b</sub></tt>=16
bit, <tt>1<sub>b</sub></tt>=32 bit</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>first operand (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>second operand (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-store">Formula: Function
if-store</a></h3>
<p>Writes a value from the source register to&nbsp;the
persistent memory if the
flag register does not equal to zero.
<br>
<em>There is no store-always function.
Loading 1 into the upper 16bits of the flag register results in an
unconditional store.</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-store: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(if-store) = 10</td>
      <td>address </td>
      <td colspan="9">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-store: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 10</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>address </td>
      <td>location in the persistent memory block (0..31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-recall">Formula: Function
if-recall</a></h3>
<p>Reads a value from the
persistent memory into the destination register&nbsp;if the
flag register does not equal to zero.
<br>
<em>There is no recall-always function.
Loading 1 into the upper 16bits of the flag register results in an
unconditional recall.</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-recall: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(if-recall) = 11</td>
      <td>address </td>
      <td colspan="9">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-recall: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 11</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>address </td>
      <td>location in the persistent memory block (0..31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>destination register (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-call-module">Formula: Function
if-call-module</a></h3>
<p>Executes a module with its parameter block starting at
the&nbsp;specified location in the persistent memory if the
flag register does not equal to zero.<br>
Only the following modules are allowed to be called:<br>
</p>
<ul>
  <li><a href="#m1">Module 1: Cut</a> </li>
  <li><a href="#m5">Module 5: Filter</a></li>
</ul>
<p><em>There is no&nbsp;call-always function.
Loading 1 into the upper 16bits of the flag register results in an
unconditional&nbsp;call.</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-call-module: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(if-call-module) = 12</td>
      <td>address </td>
      <td colspan="9">rsv</td>
      <td colspan="2">reg2</td>
      <td>rsv</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-call-module: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 12</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>address </td>
      <td>location in the persistent memory block (0..31), where
the module parameter block starts (= address of the header quadlet)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-copy">Formula: Function
if-copy</a></h3>
<p>Copies either the first source register ore the second one
into&nbsp;the destination depending on the
flag register.
<em><br>
</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-copy: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(if-copy) = 13</td>
      <td>reg1 </td>
      <td colspan="4">rsv</td>
      <td colspan="5">reg4</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-copy: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 13</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>14-10</td>
      <td>reg4</td>
      <td>second source register (0...31), used if flag
register&nbsp;equals to zero</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>first source register (0...31), used if flag register
does not equal to zero</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_root-square-add">Formula: Function
root-square-add</a></h3>
<p>Adds or subtracts the squares of two registers and calculates
the
square root of the absolute value of the sum. The result is always
positive.&nbsp;</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function root-square-add: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(root-square-add) = 14</td>
      <td>reg1</td>
      <td colspan="3">rsv</td>
      <td>sa</td>
      <td>s</td>
      <td>sub</td>
      <td colspan="3">rsv</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function root-square-add: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 14</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register (0...31)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>15-15 </td>
      <td>sa </td>
      <td>saturation mode: <tt>0<sub>b</sub></tt>=no
saturation, <tt>1<sub>b</sub></tt>=saturate on
overflow</td>
    </tr>
    <tr>
      <td>14-14 </td>
      <td>s </td>
      <td>data type: 0b=unsigned, 1b=signed</td>
    </tr>
    <tr>
      <td>13-13 </td>
      <td>sub </td>
      <td>operation: <tt>0<sub>b</sub></tt>=addition,
      <tt>1<sub>b</sub></tt>=subtraction</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>first operand (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>second operand (0...31)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_save">Formula: Function save</a></h3>
<p>Saves a value from a register into the result queue. Saves
entire 32 bit or the upper 16bit with shift.</p>
<p>Remarks:</p>
<ul>
  <li>Use this function with care. It does not enforce the <a href="#result">result queue structure</a> described
above.</li>
  <li>Only three combinations are really usefull:&nbsp;</li>
  <ul>
  </ul>
  <ol>
    <li>writing entire 32bit (dw=1)</li>
    <li>writing the upper 16bit if the register into
the upper result queue bits (dw=0, shift=0)</li>
    <li>writing the upper 16bit if the register into the lower
result
queue bits (dw=0, shift=-16).</li>
  </ol>
  <ul>
  </ul>
</ul>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function save: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(save) = 15</td>
      <td>reg1</td>
      <td colspan="2">offset</td>
      <td>dw</td>
      <td colspan="2">rsv</td>
      <td colspan="5">shift</td>
      <td colspan="2">offset</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function save: Description of Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 15</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>source register (0...31)</td>
    </tr>
    <tr>
      <td>18-17</td>
      <td>offset</td>
      <td>offset bits 9-8</td>
    </tr>
    <tr>
      <td>16-16 </td>
      <td>dw </td>
      <td>data width:<br>
      <tt>0<sub>b</sub></tt>=saves a 16 bit
value in the upper 16 bit (applies shift)<br>
      <tt>1<sub>b</sub></tt>=loads a 32 bit
value (ignores shift and saturation)</td>
    </tr>
    <tr>
      <td>13-8 </td>
      <td>shift </td>
      <td>distance of shift (-32...31)</td>
    </tr>
    <tr>
      <td>7-0 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_rotate-point">Formula: Function
rotate-point</a></h3>
<p>Rotates a point around a center point.
<em><br>
</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function rotate-point: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(rotate-point) = 16</td>
      <td>reg1 </td>
      <td colspan="4">rsv</td>
      <td colspan="5">reg4</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function rotate-point: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 16</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register, receives the rotated point, upper
16 bits receive x, lower 16 bits receive z</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>14-10</td>
      <td>reg4</td>
      <td>rotational center register,&nbsp;the rotational
centre becomes the
point x=32768, z=32768 after rotation,&nbsp;upper 16 bits contain
x, lower 16 bits contain z</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>angle of rotation in 0.01°</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register, contains the point to
rotated,&nbsp;upper 16 bits contain x, lower 16 bits contain z</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-init-temporal-filter">Formula:
Function
if-init-temporal-filter</a></h3>
<p>Sets up a temporal filter if
the
flag register does not equal to zero. The formula module provides a
memory block of 64 words for temporal filtering. Each filter consumes a
block depending on the filter width:</p>
<ul>
  <li>width +1 words for 32bit filters</li>
  <li>(width+1)/2 for 16bit filters</li>
</ul>
<p>
The filter block must be set up before the filter can be used. Because
there is no set up procedure in fomula, the filter can be cleared only
if the filter specification changes. This way, the filter is set up
only after boot and the if-init-temporal-filter command is ignored in
subsequent passes of the formula module. Alternatively, the flag
register can be used to selectively&nbsp;initialise the filter.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-init-temporal-filter: Quadlet.</caption>
  <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup><tbody>
    <tr align="center">
      <td>func(if-init-temporal-filter) = 17</td>
      <td>size</td>
      <td>f</td>
      <td>c</td>
      <td>dw</td>
      <td colspan="3">rsv</td>
      <td colspan="3">type</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-init-temporal-filter: Description of
Fields.</caption> <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 17</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>size </td>
      <td>filter size, the actual width is&nbsp;taps = 2
× size + 1</td>
    </tr>
    <tr>
      <td>18</td>
      <td>fc</td>
      <td>force clear, empty the filter if the flag register is
not equal to zero</td>
    </tr>
    <tr>
      <td>17</td>
      <td>c</td>
      <td>clear, empty the filter if
the
flag register does not equal to zero and if the the filter
specification has changed</td>
    </tr>
    <tr>
      <td>16</td>
      <td>dw</td>
      <td>dw=1 filters 32bit values, dw=0 filters 16bit values
(upper 16bit)</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>12-10</td>
      <td>type</td>
      <td>filter type:<br>
      <ol start="0">
        <li>delay, delays like the other filters but returns
original values</li>
        <li>reserved</li>
        <li>average, signed</li>
        <li>average, unsigned</li>
        <li>median, signed</li>
        <li>median unsigned</li>
        <li>reserved</li>
        <li>reserved</li>
      </ol>
      </td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>&nbsp;address into the filter
memory block (upper 16 bits)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_if-temporal-filter">Formula:
Function
if-temporal-filter</a></h3>
<p>Puts a value into the filter and returns the filtered value if
the
flag register does not equal to zero. The new value is put into the
filter first, the return value is calculated including this new value.
If the filter contains less values than specified by the size
parameter, it will grow up to the specified size. It will act like a
smaller filter until then. &nbsp;<em>
</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-temporal-filter: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(if-temporal-filter) = 18</td>
      <td>reg1 </td>
      <td colspan="4">rsv</td>
      <td colspan="5">reg4</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function if-temporal-filter: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 18</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register, the filtered value</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>14-10</td>
      <td>reg4</td>
      <td>source register (0...31), the raw value</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>flag register (0...31)</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>address into the filter
memory block (upper 16 bits)</td>
    </tr>
  </tbody>
</table>
<h3><a name="func_project-point">Formula: Function
project-point</a></h3>
<p>Projects the source point onto a line and returns the
projected point.
<em><br>
</em></p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function project-point: Quadlet.</caption> <colgroup><col width="25%"><col width="15%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="6%"><col width="9%"><col width="15%"></colgroup> <tbody>
    <tr align="center">
      <td>func(project-point) = 19</td>
      <td>reg1 </td>
      <td colspan="3">rsv</td>
      <td>rl</td>
      <td colspan="5">reg4</td>
      <td colspan="2">reg2</td>
      <td>reg3</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Function project-point: Description of Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-24 </td>
      <td>func(...)</td>
      <td>called function = 19</td>
    </tr>
    <tr>
      <td>23-19 </td>
      <td>reg1 </td>
      <td>destination register, receives the projected point,
upper 16 bits receive x, lower 16 bits receive z</td>
    </tr>
    <tr>
      <td>18</td>
      <td>rl</td>
      <td>rl=0: reg4 contains the distance to the coordinate
origin<br>
rl=1: reg4 contains the z-axis intercept (reference level)</td>
    </tr>
    <tr>
      <td>17-15</td>
      <td>rsv</td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>14-10</td>
      <td>reg4</td>
      <td>rl=0: distance to the coordinate origin<br>
rl=1: z-axis intercept (reference level)</td>
    </tr>
    <tr>
      <td>9-5 </td>
      <td>reg2 </td>
      <td>angle of line in 0.01°</td>
    </tr>
    <tr>
      <td>4-0 </td>
      <td>reg3 </td>
      <td>source register, contains the point to
rotated,&nbsp;upper 16 bits contain x, lower 16 bits contain z</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m4">Module 4: GetOutput</a></h2>
<p>The GetOutput module reads back the latest values written to
output channels and
writes them to the result block.<br>
This Module&nbsp;supports only the physically available ports
of&nbsp;scan<acronym>CONTROL</acronym>&nbsp;2810.
Consult <a href="#m4Ex">Module 4: GetOutputExtended</a>
for an extended version.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutput: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="31%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>4</td>
      <td>rsv</td>
      <td>dest</td>
      <td>rsv</td>
      <td>offset</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutput: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8</td>
      <td>offset</td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutput: Module Result Block.</caption> <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">4</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>3</td>
    </tr>
    <tr align="center">
      <td colspan="8">analogue 1</td>
      <td colspan="2">analogue 2</td>
    </tr>
    <tr align="center">
      <td>d1</td>
      <td>d2</td>
      <td>d3</td>
      <td colspan="7">reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutput: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-16 </td>
      <td>analogue 1 </td>
      <td>analogue output port 1</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>analogue 2 </td>
      <td>analogue output port 2</td>
    </tr>
    <tr>
      <td>31-31 </td>
      <td>d1 </td>
      <td>digital output port 1</td>
    </tr>
    <tr>
      <td>30-30 </td>
      <td>d2 </td>
      <td>digital output port 2</td>
    </tr>
    <tr>
      <td>29-29 </td>
      <td>d3 </td>
      <td>digital output port 3</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m4Ex">Module 4: GetOutputExtended</a></h2>
<p>The GetOutputExtended module reads back the latest values
written to
output channels and
writes them to the result block. The number of channels to include can
be specified.<br>
The numbering of channels conforms to the write functions of the
formula
module above.<br>
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutputExtended: Module Parameter Block.</caption>
  <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="16%"><col width="15%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>4</td>
      <td>rsv</td>
      <td>dest</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">2</td>
    </tr>
    <tr align="center">
      <td colspan="6">reserved</td>
      <td>channel count</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutputExtended: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8</td>
      <td>offset</td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>4-0</td>
      <td>channel count</td>
      <td>number of 16bit channels to include, must be even</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutputExtended: Module Result Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">4</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>2+(channel count)/2</td>
    </tr>
    <tr align="center">
      <td>c8</td>
      <td>c9</td>
      <td>c10</td>
      <td colspan="7">reserved</td>
    </tr>
    <tr align="center">
      <td colspan="8">channel0_16</td>
      <td colspan="2">channel1_16</td>
    </tr>
    <tr align="center">
      <td colspan="8">channel2_16</td>
      <td colspan="2">...</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetOutputExtended: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31 </td>
      <td>c8 </td>
      <td>channel 9, least significant bit</td>
    </tr>
    <tr>
      <td>30 </td>
      <td>c9 </td>
      <td>channel 9, least significant bit</td>
    </tr>
    <tr>
      <td>29 </td>
      <td>c10</td>
      <td>channel 10, least significant bit</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td>channel0_16 </td>
      <td>channel 0, 16bit value</td>
    </tr>
    <tr>
      <td>15-0 </td>
      <td>channel1_16 </td>
      <td>channel 1, 16bit value</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m5">Module 5: Filter</a></h2>
<p>This module provides various
functions for filtering profiles. The filters take one profile in the
source stripe and output a filtered profile into another stripe. The
module
parameter block consists of at least two quadlets, the header quadlet
and one parameter quadlet. Additional parameter quadlets may follow
depending on the selected filter type.</p>
<p>It is possible to use the same stripe for input and output.
Depending on the filter type, there are additional considerations:</p>
<ul>
  <li>The Resample, Average and Median type filters generally run
faster with different&nbsp;stripes. The same stripe may be used,
but then the algorithm will use the neighbouring stripe as temporary
scratch space.<em></em><br>
Example: if stripe 1 ist filtered into stripe 1 then stripe 2 will be
destroyed, if stripe 2 is filtered in place then stripe 1 will be
destroyed.</li>
  <li>Copy, Math &nbsp;and FillGaps type filters do not need
scratch space. They can be used with different stripes or in place as
well. They run faster in place in most cases.</li>
  <li>Stripe 4 contains the time stamp. The filter module
respects it. This means that the very last point of the profile will be
lost if the destination stripe is 4. Accordingly, the module will
generate&nbsp;an invalid point as new last point if the source
stripe is 4. It is generally not recomended to use the fourth stripe as
source or destination.</li>
</ul>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Filter: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="25%"></colgroup>
  <tbody>
    <tr align="center">
      <td>5</td>
      <td colspan="2">src</td>
      <td colspan="2">dest</td>
      <td colspan="4">rsv</td>
      <td colspan="8">rsv</td>
      <td>&#8805;2</td>
    </tr>
    <tr align="center">
      <td>type</td>
      <td>x</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>f</td>
      <td>t</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>r</td>
      <td>algorithm/size</td>
    </tr>
    <tr align="center">
      <td colspan="18">parameter 2 (depending on type)</td>
    </tr>
    <tr>
      <td colspan="18" rowspan="1" align="center">parameter
3 (depending on type)</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Filter: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22</td>
      <td>src</td>
      <td>source stripe</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv, r </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>31-24</td>
      <td>type</td>
      <td>filter type, see table of available types below</td>
    </tr>
    <tr>
      <td>23</td>
      <td>x</td>
      <td>expand profile, create new valid points at the
beginning and at the end of the profile</td>
    </tr>
    <tr>
      <td>15</td>
      <td>f</td>
      <td>fill, create new valid points for invalid points
between already valid points</td>
    </tr>
    <tr>
      <td>14</td>
      <td>t</td>
      <td>external tracing, see Clip filter types</td>
    </tr>
    <tr>
      <td>7-0</td>
      <td>algorithm/size</td>
      <td>specific algorithm for filtering or filter size
(depending on filter type)</td>
    </tr>
  </tbody>
</table>
<p> The filter module does not
produce a result block.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Filter: Available Filter types.</caption> <thead>
  <tr>
    <th>Type</th>
    <th>Name</th>
    <th>Parameters</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>0</td>
      <td>Resample</td>
      <td>x, f, algorithm, parameter&nbsp;2</td>
      <td>resamples the profile to have equally spaced points
inside a
range from MinX to MaxX, keeps the point with larger distance in case
of ambiguity. Parameters:<br>
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <tbody>
          <tr>
            <td>x</td>
            <td>create new valid z values at the beginning and
the end of the profile by copying the first and last valid z,
respectively</td>
          </tr>
          <tr>
            <td>f</td>
            <td>interpolate new valid z values for gaps in the
profile</td>
          </tr>
          <tr>
            <td>algorithm</td>
            <td>0 = nearest neighbour<br>
1 = linear interpolation</td>
          </tr>
          <tr>
            <td>parameter 2</td>
            <td>MinX (upper 16 bits), MaxX (lower 16 bits)</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
    <tr>
      <td>1</td>
      <td>ResampleAll</td>
      <td>x, f, algorithm, parameter&nbsp;2</td>
      <td>similar to Resample, but filters all profile
characteristics, linear interpolations works only for z</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Median</td>
      <td>size</td>
      <td>applies a median filter to field z, leaves all other
fields untouched, number of taps = 2 × size + 1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>MedianAll</td>
      <td>size</td>
      <td>applies a median filter to field z, copies all other
fields, number of taps = 2 × size + 1</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Average</td>
      <td>size</td>
      <td>applies an average filter to field z, leaves all other
fields untouched, number of taps = 2 × size + 1</td>
    </tr>
    <tr>
      <td>5</td>
      <td>AverageAll</td>
      <td>size</td>
      <td>applies an average filter to field z, copies all other
fields, number of taps = 2 × size + 1</td>
    </tr>
    <tr>
      <td>6</td>
      <td>Copy</td>
      <td>x, f</td>
      <td>copies the field z:<br>
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <tbody>
          <tr>
            <td>x</td>
            <td>create new valid z values at the beginning and
the end of the profile by copying the first and last valid z,
respectively</td>
          </tr>
          <tr>
            <td>f</td>
            <td>interpolate new valid z values for gaps in the
profile, use nearest valid z</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
    <tr>
      <td>7</td>
      <td>CopyAll</td>
      <td>x, f</td>
      <td>copies all fields:<br>
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <tbody>
          <tr>
            <td>x</td>
            <td>create new valid z values at the beginning and
the end of the profile by copying the first and last valid z,
respectively</td>
          </tr>
          <tr>
            <td>f</td>
            <td>interpolate new valid z values for gaps in the
profile, use nearest valid z</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
    <tr>
      <td>8</td>
      <td>Math</td>
      <td>algorithm</td>
      <td>applies a mathematical function in a point wise manner<br>
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <thead align="left"> <tr>
          <th>algorithm</th>
          <th>description</th>
        </tr>
        </thead> <tbody>
          <tr>
            <td align="center">0</td>
            <td>z_dest = z_src - z_dest + 32768</td>
          </tr>
          <tr>
            <td align="center">128</td>
            <td>rotates the source profile by a specific angle,
parameter
2
contains the rotational centre (upper bits x, lower bits z), parameter
3 contains the angle (lower 16 bits), the rotational centre becomes the
point x=32768, z=32768 sensor units in the resulting profile,<br>
bits 31..30 determine, how subsequent modules treat the result with
respect to the order of the profile points: <br>
00<sub>b</sub>: do not change the order<br>
01<sub>b</sub>: set&nbsp;ascending order <br>
10<sub>b</sub>: set descending order<br>
11<sub>b</sub>: automatically determine the order (flip
ordering if &nbsp;the absolute value of the angle is
&gt;90°</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
    <tr>
      <td>9</td>
      <td>MathAll</td>
      <td>algorithm</td>
      <td>like Math, but copies also the additional peak fields</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Clip</td>
      <td>t,<br>
algorithm,<br>
parameter&nbsp;2, parameter&nbsp;3,<br>
parameter 4,<br>
parameter 5</td>
      <td>This filter type has two shapes depending on
the parameter block length.<br>
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <thead align="left"> <tr>
          <th>length</th>
          <th>description</th>
        </tr>
        </thead>
        <tbody>
          <tr>
            <td>4</td>
            <td>Parameter 2 and 3 define a rectangular region,
upper 16
bits of parameter 2 define MinX, lower 16 bits define MinZ, parameter 3
defines MaxX and MaxZ, the input profile is clipped to this region</td>
          </tr>
          <tr>
            <td>6</td>
            <td>Parameter 2 and 3 define MinX and MinZ
respectively, parameter 4 contains the range width (upper 16 bit) and
range height (lower 16bit).<br>
Parameter 5 contains&nbsp; the stripe number (bits 14 and 15) and
strip offset (bits 0..13) where the anchor is taken from.<br>
t determines the dynamic tracing:<br>
            <tt>t=0<sub>b</sub></tt>: static, no
external tracing, the range values above are absolute sensor
coordinates<br>
            <tt> t=1<sub>b</sub></tt>: dynamic
tracing,
the anchor point is read from previous result using stripe and quadlett
offset fields, the range values above will be shifted by this
anchor point. If the anchor point is invalid, then an empty profile (all points invalid) will be output.</td>
          </tr>
        </tbody>
      </table>
algorithm=0 marks points located outside as invalid, algorithm=1
inverts the clipping and marks the inside points as invalid</td>
    </tr>
    <tr>
      <td>11</td>
      <td>ClipAll</td>
      <td>t,<br>
algorithm,<br>
parameter&nbsp;2, parameter&nbsp;3,<br>
parameter 4,<br>
parameter 5</td>
      <td>like Clip, but copies also the additional peak fields;
the legacy <a href="#m1">Cut-Modul</a> uses this
filter type now.</td>
    </tr>
    <tr>
      <td>12</td>
      <td>FillGap</td>
      <td>algorithm, x, f, parameter&nbsp;2</td>
      <td>fills the largest gap with one or two new points if it
consists of at least one invalid
point and if it is larger or equal to the minimum size
(upper 16 bits of parameter 2); the generated points reside at a
distance of zo (lower 16 bits of parameter 2), their x positions are
copied from the adjacent valid point; if only one point is generated
(single invalid point gap) then the x coordinate is the average of the
adjacent points. The algorithm parameter determines how gaps are
compared to find the largest one. Note, only&nbsp;the largest gap
is
considered. If it does not contain at least one invalid point, no new
points will be generated.<br>
comparison algorithm:<br>
0 = euklidian distance<br>
1 = absolute x distance<br>
2 = absolute z distance
      <table frame="none" rules="rows" cellspacing="1" cellpadding="3" border="1">
        <tbody>
          <tr>
            <td>x</td>
            <td>create valid points at the beginning or the end
of the profile, if the profile starts or end with invalid points</td>
          </tr>
          <tr>
            <td>f</td>
            <td>create valid points for inner gaps</td>
          </tr>
        </tbody>
      </table>
      </td>
    </tr>
    <tr>
      <td>13</td>
      <td>FillGapAll</td>
      <td>algorithm, x, f, parameter&nbsp;2</td>
      <td>like FillGap, but copies also the additional peak
fields</td>
    </tr>
    <tr>
      <td>14</td>
      <td>Split</td>
      <td>algorithm, parameter&nbsp;2</td>
      <td>the input profile is divided, parameter 2 determines
the point where to split,
the algorithm determines the details:<br>
0 = starts from left (small x) until (including) the split point<br>
1 = starts from left (small x) until (excluding) the split point<br>
2 = starts from right (large x) until (including) the split point<br>
3 = starts from right (large x) until (excluding) the split point<br>
If the split point is not found, then the behaviour is undefined: the whole profile may be copied or deleted.</td>
    </tr>
    <tr>
      <td>15</td>
      <td>SplitAll</td>
      <td>algorithm, parameter&nbsp;2</td>
      <td>like Split, but copies also the additional peak fields.</td>
    </tr>
    <tr>
      <td>16</td>
      <td>Join</td>
      <td>&nbsp;</td>
      <td>Fill invalid points of the destination stripe with points of the source stripe, only x and z will be copied</td>
    </tr>
    <tr>
      <td>17</td>
      <td>JoinAll</td>
      <td>&nbsp;</td>
      <td>Fill invalid points of the destination stripe with points of the source stripe, all peak fields will be copied</td>
    </tr>
  </tbody>
</table>
<br>
<strong>Remarks:</strong>
<ul>
  <li>The Median and Average filters do not preserve edges. They output a valid point only if all points in
  the filter window are valid.</li>
  <li>The Resample filter is recommended to generate interpolated points. It interpolates z-coordinates and
  generates appropriate x-coordinates.</li>
  <li>The Copy-filter may be used to fill holes in the profile. The filter generates points with a valid z-coordinate
  and an x-coordinate x = 0. These points should be used only in conjuction with a subsequent Median- or Average-Filter.
  The generated points should not be used for subsequent profile processing like Beadfinder etc. They should be made
  invalid with an appropriate Clip-filter before further processing.</li>
</ul>

<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m6">Module 6: Comment</a></h2>
<p>The only purpose of the Comment module is to include an
arbitrary comment into the result queue. The contents of the module is
copied without any change.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Comment: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="16%"><col width="15%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>6</td>
      <td>rsv</td>
      <td>dest</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">&#8805;1</td>
    </tr>
    <tr align="center">
      <td colspan="7">first comment quadlett</td>
    </tr>
    <tr align="center">
      <td colspan="7">second comment quadlett</td>
    </tr>
    <tr align="center">
      <td colspan="7">...</td>
    </tr>
    <tr align="center">
      <td colspan="7">last comment quadlett</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Comment: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Comment: Module Result Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="13%"><col width="3%"><col width="3%"><col width="19%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>6</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td colspan="3">rsv</td>
      <td>&#8805;1</td>
    </tr>
    <tr align="center">
      <td colspan="8">first comment quadlett</td>
    </tr>
    <tr align="center">
      <td colspan="8">second comment quadlett</td>
    </tr>
    <tr align="center">
      <td colspan="8">...</td>
    </tr>
    <tr align="center">
      <td colspan="8">last comment quadlett</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m7">Module 7: GetTimestamp</a></h2>
<p>The GetTimestamp module reads and decodes the timestamp of the
profile and writes it to the result block.<br>
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetTimestamp: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="16%"><col width="15%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>7</td>
      <td>rsv</td>
      <td>dest</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetTimestamp: Parameter Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetTimestamp: Module Result Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="13%"><col width="3%"><col width="3%"><col width="19%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>7</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td colspan="3">rsv</td>
      <td>6</td>
    </tr>
    <tr align="center">
      <td>reserved</td>
      <td colspan="7">profile number</td>
    </tr>
    <tr align="center">
      <td colspan="4">input edges</td>
      <td>e</td>
      <td>a</td>
      <td colspan="2">cmm trigger count</td>
    </tr>
    <tr align="center">
      <td colspan="8">start time µs</td>
    </tr>
    <tr align="center">
      <td colspan="8">stop time µs</td>
    </tr>
    <tr align="center">
      <td colspan="8">shutter time µs</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetTimestamp: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-0 </td>
      <td>profile number </td>
      <td>number of the actual profile</td>
    </tr>
    <tr>
      <td>31-16 </td>
      <td> input edges</td>
      <td>input edge count × 2&nbsp;since activation</td>
    </tr>
    <tr>
      <td>15 </td>
      <td>e</td>
      <td>set if an active cmm trigger edge was output during the
shutter interval</td>
    </tr>
    <tr>
      <td>14 </td>
      <td>a </td>
      <td>set if cmm trigger output was active</td>
    </tr>
    <tr>
      <td>13-0 </td>
      <td>cmm trigger count </td>
      <td>number of cmm trigger pulses issued since activation</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>start time</td>
      <td>absolute time when the shutter has opened in
µs (clock has a
period of 128 seconds)</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>stop time</td>
      <td>absolute time when the shutter has closed in
µs (clock has a
period of 128 seconds)</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>shutter time</td>
      <td>shutter open time in µs (always smaller than
128 seconds)</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m8">Module 8: WAGObuscoupler</a></h2>
<p>This module controls how a WAGO buscoupler device 750-339 or
750-841 is
used as ouput channels. Currently only a compatibility mode is
supported. The compatibility mode is activated by default in the scan<acronym>CONTROL</acronym>&nbsp;2710
devices for the 750-339 and deactivated
by default in the scan<acronym>CONTROL</acronym>&nbsp;2810
devices and for the 750-841. Th eethernet buscoupler z50-841 can be
used only after a valid IP address has been configured.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>WAGObuscoupler: Module Parameter Block.</caption>
  <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="13%"><col width="22%"><col width="3%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>8</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td colspan="2">rsv</td>
      <td>2 or 3</td>
    </tr>
    <tr>
      <td colspan="5" align="center">reserved</td>
      <td>N</td>
      <td colspan="1" align="center">mode</td>
    </tr>
    <tr>
      <td colspan="7" align="center">IP address
(750-841 only)</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>WAGObuscoupler:&nbsp;Parameter&nbsp;Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>8</td>
      <td>N</td>
      <td>Invert all single bit outputs</td>
    </tr>
    <tr>
      <td>7..0</td>
      <td>mode</td>
      <td>0 = disable<br>
1 = compatibility mode<br>
2 = device default mode</td>
    </tr>
    <tr>
      <td>31..0</td>
      <td>IP address</td>
      <td>IP address of the target buscoupler 750-841, ignored
for the 750-339</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m9">Module 9: GetHoldingRegisters</a></h2>
<p>This module reads back the contents of the Modbus holding
registers.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetHoldingRegisters: Module Parameter Block.</caption>
  <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="32%"><col width="6%"><col width="19%"></colgroup><tbody>
    <tr align="center">
      <td>9</td>
      <td>rsv</td>
      <td>dst</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">2</td>
    </tr>
    <tr>
      <td colspan="6" align="center">reserved</td>
      <td colspan="1" align="center">register count</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetHoldingRegisters:&nbsp;Parameter&nbsp;Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>5..0</td>
      <td>register count</td>
      <td>number of holding registers up to 32, must be even</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetHoldingRegisters: Module Result Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">9</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>1+(register count)/2</td>
    </tr>
    <tr align="center">
      <td colspan="8">register0_16</td>
      <td colspan="2">register1_16</td>
    </tr>
    <tr align="center">
      <td colspan="8">register2_16</td>
      <td colspan="2">...</td>
    </tr>
  </tbody>
</table>
<br>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m10">Module 10: Gap Finder</a></h2>
<p>This module finds the largest gap between two valid points in
the source profile. Largest gap means largest euklidian distance
between two subsequent valid points, regardless whether there are also
invalid points in the gap.</p>
<p>The Gap Finder fails only if the profile
contains less than 2 valid points. All the results are set to zero in
this case. Except for the x-coordinates of points which are set to
32768.</p>
<p>The left point will have a smaller x-coordinate than the
right&nbsp;point in most cases. The gap size x will be positive
accordingly. Only if the profile is recurrent at the position of the
gap, then the left point will have a larger x-coordinate and hence the
gap width will be negative.&nbsp;
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Gap Finder: Module Parameter Block.</caption> <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="6%"><col width="32%"><col width="6%"><col width="19%"></colgroup><tbody>
    <tr align="center">
      <td>10</td>
      <td>src</td>
      <td>dst</td>
      <td>ec</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">2</td>
    </tr>
    <tr align="center">
      <td colspan="5">rsv</td>
      <td colspan="3">algorithm</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Gap Finder:&nbsp;Parameter&nbsp;Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22</td>
      <td>src</td>
      <td>source stripe</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>19</td>
      <td>ec</td>
      <td>enable error code in Module Result Block</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>7-0</td>
      <td>algorithm</td>
      <td>comparison algorithm:<br>
0 = euklidian distance<br>
1 = absolute x distance<br>
2 = absolute z distance</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>Gap finder: Module Result Block.</caption> <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">10</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>7 or 8</td>
    </tr>
    <tr align="center">
      <td colspan="8">left point x</td>
      <td colspan="2">left point z</td>
    </tr>
    <tr align="center">
      <td colspan="8">centre point x</td>
      <td colspan="2">centre point z</td>
    </tr>
    <tr align="center">
      <td colspan="8">right point x</td>
      <td colspan="2">right point z</td>
    </tr>
    <tr align="center">
      <td colspan="10">gap size x or width (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="10">gap size z or flush (signed)</td>
    </tr>
    <tr align="center">
      <td colspan="10">euklidian gap size (unsigned)</td>
    </tr>
    <tr align="left">
      <td colspan="8" align="center"> rsv</td>
      <td colspan="2">optional error code if ec is 1<br>
                      0 = no error<br>
                     10 = no valid points<br>
    </td></tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m11">Module 11: GetInfo</a></h2>
<p>This module provides various information about the sensor state.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetInfo: Module Parameter Block.</caption>
  <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="6%"><col width="32%"><col width="6%"><col width="19%"></colgroup><tbody>
    <tr align="center">
      <td>11</td>
      <td>rsv</td>
      <td>dst</td>
      <td>rsv</td>
      <td>offset</td>
      <td colspan="2">1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetInfo:&nbsp;Parameter&nbsp;Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetInfo: Module Result Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">11</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>3</td>
    </tr>
    <tr align="center">
        <td colspan="2">rsv</td>
        <td colspan="3">laserinput</td>
      <td colspan="3">sensor temperature</td>
      <td colspan="2">processing time [µs]</td>
    </tr>
    <tr align="center">
      <td colspan="10">option number</td>
    </tr>

  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetInfo: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-29</td>
      <td>rsv</td>
      <td>reserved </td>
    </tr>
    <tr>
      <td>28</td>
      <td>laserinput</td>
      <td>state of the external laserinput </td>
    </tr>
    <tr>
      <td>27-16 </td>
      <td>temperature</td>
      <td>temperature with a resolution of 0.1K</td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>processing time</td>
      <td>processing time in µs</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>option number</td>
      <td>ASCII encoded option number</td>
    </tr>
  </tbody>
</table>

<br>
<p align="right">Back to <a href="#contents">Contents</a>.
</p>
<h2><a name="m12">Module 12: MeasurementServer</a></h2>
<p>This module controls the channel where data written with <a href="#func_write-serial">Formula: Function if-write-serial</a>
will be sent.
</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>MeasurementServer: Module Parameter Block.</caption>
  <colgroup><col width="25%"><col width="6%"><col width="6%"><col width="13%"><col width="22%"><col width="3%"><col width="25%"></colgroup><tbody>
    <tr align="center">
      <td>12</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td colspan="2">rsv</td>
      <td>3</td>
    </tr>
    <tr>
      <td colspan="4" align="center">port</td>
      <td colspan="2" align="center">rsv</td>
      <td colspan="1" align="center">mode</td>
    </tr>
    <tr>
      <td colspan="7" align="center">IP address
      </td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>MeasurementServer</caption><caption>MeasurementServerMeasurementServer</caption><caption>MeasurementServer:&nbsp;Parameter&nbsp;Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>7..0</td>
      <td>mode</td>
      <td>0 = disable<br>
1 = serial port (default)<br>
2 = UDP</td>
    </tr>
    <tr>
      <td>31..16</td>
      <td>port</td>
      <td>destination port</td>
    </tr>
    <tr>
      <td>31..0</td>
      <td>IP address</td>
      <td>destination IP address</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>

<h2><a name="m13">Module 13: GetProfileInfo</a></h2>
<p>This module provides the average values of different profile parameters from the selected source stripe.</p>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetProfileInfo: Module Parameter Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="6%"><col width="31%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">13</td>
      <td>src</td>
      <td>dst</td>
      <td>rsv</td>
      <td>offset</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetProfileInfo: Parameter Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22</td>
      <td>src</td>
      <td>source stripe</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe,
enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>

<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetProfileInfo: Module Result Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">13</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>4</td>
    </tr>
    <tr align="center">
      <td colspan="8">ØW</td>
      <td colspan="2">ØI</td>
    </tr>
    <tr align="center">
      <td colspan="8">ØThr</td>
      <td colspan="2">vP</td>
    </tr>
    <tr align="center">
      <td colspan="10">ØM0</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>GetProfileInfo: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>ØW</td>
      <td>average width of reflection in pixels</td>
    </tr>
    <tr>
      <td>15..0</td>
      <td>ØI</td>
      <td>average intensity (intensity = height + threshold)</td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>ØThr</td>
      <td>average threshold</td>
    </tr>
    <tr>
      <td>15..0</td>
      <td>vP</td>
      <td>count of valid points</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>ØM0</td>
      <td>average of M0</td>
    </tr>
  </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>





<h2><a name="m14">Module 14: CircleFit</a></h2>
Kreispassung


<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>CircleFit: Module Parameter Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="6%"><col width="31%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">14</td>
      <td>src</td>
      <td>dst</td>
      <td>rsv</td>
      <td>offset</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>CircleFit: Parameter Fields.</caption>
  <thead> <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>23-22</td>
      <td>src</td>
      <td>source stripe</td>
    </tr>
    <tr>
      <td>21-20 </td>
      <td>dest </td>
      <td>destination stripe</td>
    </tr>
    <tr>
      <td>17-8 </td>
      <td>offset </td>
      <td>quadlet offset inside of the destination stripe, enables concatenation of result blocks</td>
    </tr>
    <tr>
      <td>&nbsp;</td>
      <td>rsv </td>
      <td>reserved</td>
    </tr>
  </tbody>
</table>

<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>CircleFit: Module Result Block.</caption>
  <colgroup><col width="3%"><col width="3%"><col width="3%"><col width="3%"><col width="12%"><col width="6%"><col width="6%"><col width="12%"><col width="25%"><col width="25%"></colgroup> <tbody>
    <tr align="center">
      <td colspan="5">14</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>rsv</td>
      <td>6</td>
    </tr>
    <tr align="center">
      <td colspan="8">rsv</td>
      <td colspan="2">ec</td>
    </tr>
    <tr align="center">
      <td colspan="10">x<sub>c</sub></td>
    </tr>
    <tr align="center">
      <td colspan="10">z<sub>c</sub></td>
    </tr>
    <tr align="center">
      <td colspan="10">radius</td>
    </tr>
    <tr align="center">
      <td colspan="8">vertex x<sub>c</sub></td>
      <td colspan="2">vertex z<sub>c</sub></td>
    </tr>
  </tbody>
</table>
<br>
<table frame="box" cellspacing="1" cellpadding="3" border="1">
  <caption>CircleFit: Result Fields.</caption> <thead>
  <tr>
    <th>Bits</th>
    <th>Field</th>
    <th>Description</th>
  </tr>
  </thead> <tbody>
    <tr>
      <td>31-16</td>
      <td>rsv</td>
      <td>reserved</td>
    </tr>
    <tr>
      <td style="text-align:right">15-0</td>
      <td>ec</td>
      <td>0 = no error<br>
                      <br>
         10 = no valid points<br>
         <br>
         31 = no vertex found<br>
      </td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>x<sub>c</sub></td>
      <td> center coordinate x (signed)</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>z<sub>c</sub></td>
      <td>center coordinate z (signed)</td>
    </tr>
    <tr>
      <td>31-0</td>
      <td>r</td>
      <td>radius (unsigned)</td>
    </tr>
    <tr>
      <td>31-16</td>
      <td>x<sub>c</sub></td>
      <td>vertex coordinate x</td>
    </tr>
    <tr>
      <td>15-0</td>
      <td>z<sub>c</sub> </td>
      <td>vertex coordinate z</td>
    </tr>


    </tbody>
</table>
<p align="right">Back to <a href="#contents">Contents</a>.</p>









<h2><a name="m128">Module 128: gapCONTROL Results</a></h2>
<p>This special module contains the results of the gapCONTROL
queue.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m129">Module 129: ConfigTools Results</a></h2>
<p>This special module contains the results of the ConfigTools
queue.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m130">Module 130: Application Results</a></h2>
<p>This special module contains the results of the Application
queue.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<h2><a name="m131">Module 131: General Results</a></h2>
<p>This special module contains the results of the General
queue.</p>
<p align="right">Back to <a href="#contents">Contents</a>.</p>
<hr>


</body></html>