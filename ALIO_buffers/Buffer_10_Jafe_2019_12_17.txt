! ROUTINE REV - 038 - custom for two z's
!
! DEFINE HOMING VARIABLES			
GLOBAL REAL AXIS_INDEX, AXIS_QTY, GANT_ORTHO, SETSPEEDVARS, SYSTYPE, XYCOMP, ZCOMP, UpdateUPOS
GLOBAL REAL AXIS_HOME(8), AXIS_LIMITS(8), A_N(8), COMMUT_EXCITATION(8), COMMUT_ON(8), GANT_AXES(8)
GLOBAL REAL HARDLIMITS(8), HOME_DIGITAL(8), HOME_DIR(8), HOME_FLAG(8), LSOFTLIMIT(8), RSOFTLIMIT(8), STD_AXES(3), VELOCITY(8)
GLOBAL REAL H_O(8)

GLOBAL REAL StepX(11), LdaX(3)(11), StrX(3)(11), FlatX(3)(11), XStepY(3), YawX(11)
GLOBAL REAL StepY(11), LdaY(3)(11), StrY(3)(11), FlatY(3)(11), YStepX(3), YawY(11)
GLOBAL REAL StepZ(11), LdaZ(11)
GLOBAL REAL ErrorCompXAxis, ErrorCompYAxis, ErrorCompZAxis
GLOBAL REAL I_X1, I_X2, I_Y, I_Z, T_1

GLOBAL REAL ErrorCompZ2Axis, StepZ2(11), LdaZ2(11), I_Z2, FlatX2(3)(11), FlatY2(3)(11)
!!!!!!!!!!!!!!!!!!!!!!!!! MODIFY THESE !!!!!!!!!!!!!!!!!!!!!!!!!!
! SET HOMING CONSTANTS
! AXIS NAMES AND CONSTANTS BEYOND THE "AXIS_QTY" VALUE WILL BE IGNORED
! CURRENT MAXIMUM AXIS_QTY IS 8

! GLOBAL CONSTANTS
AXIS_QTY=6      	! DEFINE THE NUMBER OF AXIS (eg, XY SYSTEM = 2)
XYCOMP=1			! DOES THE XY INCLUDE A COMPENSATION TABLE (0=NO; 1=LdaX, LdaY, StrX, StrY, T_1, YawX, YawY)
ZCOMP=2				! DOES THE Z INCLUDE A COMPENSATION TABLE (0=NO, 1=LdaZ, 2=LdaZ, FlatX, FlatY)
SETSPEEDVARS=0  	! SET THE SPEED VARIABLES AT THE END OF HOMING? (0=NO, 1=YES)
SYSTYPE=2			! SET WHICH SYSTEM IS BEING HOMED (0=STANDARD SYSTEM, 1=HYBRID HEXAPOD, 2=GANTRY, 3=GANTRY HYBRID HEXAPOD)

! AXIS ASSIGNMENTS FOR ERROR COMPENSATION (THESE NUMBERS ARE THE INDEX NUMBER OF A_N)
! STANDARD (SYSTYPE=0)
STD_AXES(0)=0		! SET THE BOTTOM AXIS		(eg, X-LINEAR)
STD_AXES(1)=1		! SET THE TOP AXIS			(eg, Y-LINEAR)
STD_AXES(2)=2		! SET THE ORTHOGONAL AXIS	(eg, Z-LINEAR)

! GANTRY (SYSTYPE=2)
GANT_AXES(0)=0		! SET THE MASTER GANTRY AXIS		(eg, X-LINEAR IN GANTRY MODE)
GANT_AXES(1)=1		! SET THE SLAVE GANTRY AXIS			(eg, X-YAW IN GANTRY MODE)
GANT_AXES(2)=2		! SET THE CROSS GANTRY AXIS			(eg, Y-LINEAR)
GANT_AXES(3)=3		! SET THE ORTHOGONAL GANTRY AXIS	(eg, Z-LINEAR)
GANT_AXES(4)=4		! SET THE 2nd ORTHOGONAL GANTRY AXIS	(eg, Z-LINEAR)
! GANTRY HOME OFFSETS ARE SPECIAL
!	- H_O(GANT_AXES(0)) IS THE X-LINEAR OFFSET (IN MM)
!	- H_O(GANT_AXES(1)) IS THE MM OFFSET FOR SETTING ORTHO (IE, DIFFERENCE BETWEEN THE INDICES) 

! AXIS 0 CONSTANTS
! SN: XXXXXX
A_N(0)=0          ! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(0)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(0)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(0)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(0)= 0 !-1.5		! HOME OFFSET FOR AXIS
VELOCITY(0)=30	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(0)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(0)=6 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(0)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(0)=0			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(0)=500.2		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(0)=-500.2	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 1 CONSTANTS
! SN: XXXXXX
A_N(1)=2          ! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(1)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(1)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(1)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(1)=0!2.287867 		! HOME OFFSET FOR AXIS
VELOCITY(1)=30	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(1)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(1)=6 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(1)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(1)=0		! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(1)=500.2		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(1)=-500.2	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 2 CONSTANTS
! SN: XXXXXX
A_N(2)=1          ! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(2)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(2)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(2)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(2)=0		! HOME OFFSET FOR AXIS
VELOCITY(2)=50	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(2)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(2)=7 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(2)=1         ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(2)=0			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(2)=520.5		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(2)=-520.5	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 3 CONSTANTS
! SN: XXXXXX
A_N(3)=4          ! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(3)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(3)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(3)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(3)=0		! HOME OFFSET FOR AXIS
VELOCITY(3)=10	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(3)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(3)=4 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(3)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(3)=0			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(3)=101		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(3)=-101	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 4 CONSTANTS
! SN: XXXXXX
A_N(4)=5         ! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(4)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(4)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(4)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(4)=0		! HOME OFFSET FOR AXIS
VELOCITY(4)=10	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(4)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(4)=4 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(4)=1         ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(4)=0			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(4)=101		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(4)=-101	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 5 CONSTANTS
! SN: XXXXXX
A_N(5)=6         	! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(5)=0        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(5)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(5)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(5)=0		! HOME OFFSET FOR AXIS
VELOCITY(5)=45	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(5)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(5)=5 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(5)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(5)=1			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(5)=99999		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(5)=-99999	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 6 CONSTANTS
! SN: XXXXXX
A_N(6)=6         	! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(6)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(6)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(6)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(6)=0		! HOME OFFSET FOR AXIS
VELOCITY(6)=25	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(6)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(6)=10 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(6)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(6)=1			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(6)=99999		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(6)=-99999	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

! AXIS 7 CONSTANTS
! SN: XXXXXX
A_N(7)=7         	! DEFINE THE AXIS NAME (0,1,X,A,ETC) INPUT "N" FOR NO AXIS
AXIS_LIMITS(7)=1        ! AXIS LIMIT CONFIG (0=ROTARY WITHOUT LIMITS, 1=LINEAR WITH LIMITS, 2=LINEAR WITHOUT LIMITS (USES THE HARD STOPS))
HOME_DIGITAL(7)=0	    ! HOME DIGITAL FOR AXIS (0=ANALOG, 1=DIGITAL)
HOME_DIR(7)=1		    ! HOME DIRECTION FOR AXIS (-1 OR 1)
H_O(7)=0		! HOME OFFSET FOR AXIS
VELOCITY(7)=10	        ! HOMING VELOCITY FOR AXIS (MUST BE A LOW VELOCITY IF AXIS IS LINEAR WITHOUT LIMITS)
COMMUT_ON(7)=1          ! COMMUTE (0=NO, 1=YES)
COMMUT_EXCITATION(7)=10 ! EXCITATION CURRENT PERCENT (SET COMMUTATION CURRENT TO MAX. 15% NTM CURRENT)
AXIS_HOME(7)=1          ! SHOULD THE AXIS BE HOMED? (0=NO, 1=YES)
HARDLIMITS(7)=1			! SHOULD HARD LIMTS BE USED? (0=SOFT LIMITS, 1=HARD LIMITS)
RSOFTLIMIT(7)=99999		! IF HARDLIMITS(x)=0, THEN DEFINE THE RIGHT SOFT LIMIT.
LSOFTLIMIT(7)=-99999	! IF HARDLIMITS(x)=0, THEN DEFINE THE LEFT SOFT LIMIT.

!!!!!!!!!!!!!!!!!!!!!! END MODIFY SECTION !!!!!!!!!!!!!!!!!!!!!!!

CALL Initialize

PFLAGS(2).0=1
AXIS_INDEX=3
CALL COMM_AND_FLAGS
AXIS_INDEX=4
CALL COMM_AND_FLAGS
JOG (4),+
JOG (5),+
WHILE (^FAULT(4).#RL | ^FAULT(5).#RL)
	BLOCK
		IF FAULT(4).#RL
			HALT 4
		END
		IF FAULT(5).#RL
			HALT 5
		END
	END
END
HALT ALL; TILL ^MST(4).#MOVE; TILL ^MST(5).#MOVE
ENABLE (4,5)
PTP/er (4,5),-5,-5


IF SYSTYPE=0	! STANDARD
	! HOMES EACH AXIS THROUGH THE FOLLOWING SEQUENCE (Rotary sequence differs, see note below)
	! - Commutate the motor.
	! - Move to the left/right end of travel.
	! - Move toward the encoder index.
	! - Once index is seen, halt
	! - Set the axis origin to the position of index.
	! - Move to the origin. 
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		CALL StdHome
		CALL SetLimitMasking		! SETS THE SOFT OR HARD LIMITS
		PTP/e (A_N(AXIS_INDEX)), 0	! MOVE AXIS TO ZERO
		AXIS_INDEX=AXIS_INDEX+1		! INCREMENT AXIS INDEX	
	END

	! IF USER DESIRES, SET VELOCITY AND ACCELERATION
	IF(SETSPEEDVARS=1)
		CALL SetUserVelAcc
	END
	
	! IF ERROR COMP IS ON, MOVE TO INDEX MARKS BEFORE ERROR COMP
	IF AXIS_INDEX=100!^XYCOMP=0 | ^ZCOMP=0
		AXIS_INDEX=0
		WHILE(AXIS_INDEX < AXIS_QTY)
			PTP (A_N(AXIS_INDEX)), -H_O(AXIS_INDEX)
			AXIS_INDEX=AXIS_INDEX+1
		END
		! WAIT FOR ALL MOTION TO STOP
		AXIS_INDEX=0
		WHILE AXIS_INDEX < AXIS_QTY
			TILL MST(A_N(AXIS_INDEX)).#MOVE=0
			AXIS_INDEX=AXIS_INDEX+1
		END
	END
	WAIT 500
	
	! ERROR COMPENSATION
	IF XYCOMP=0
		CALL ErrorComp0
	END
	IF XYCOMP=1
		CALL ErrorComp1
	END
	IF ZCOMP=1
		CALL ErrorCompZ1
	END
	IF ZCOMP=2
		CALL ErrorCompZ2
	END
	
	WAIT 1000
	! MOVE AXES TO ZERO
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		PTP (A_N(AXIS_INDEX)), 0
		AXIS_INDEX=AXIS_INDEX+1
	END
	WAIT 100
	! WAIT FOR ALL MOTION TO STOP
	AXIS_INDEX=0
	WHILE AXIS_INDEX < AXIS_QTY
		TILL MST(A_N(AXIS_INDEX)).#MOVE=0
		AXIS_INDEX=AXIS_INDEX+1
	END
END

IF SYSTYPE=1	! HYBRID HEXAPOD
	! TRIPOD HOMING (AXES 2,3,4)
	! - Commutate the motors on axes 2-4.
	! - Move all links (axes 2-4) to the top/bottom end of travel.
	! - Move all links toward the encoder indices.
	! - Once indicies are seen, halt
	! - Set the axis origin to the position of index.
	! - Move to the origin.
	CALL TripodHome	

	! STANDARD HOMING (AXES 0,1,5) 
	! HOMES EACH AXIS THROUGH THE FOLLOWING SEQUENCE (Rotary sequence differs, see note below)
	! - Commutate the motor.
	! - Move to the left/right end of travel. 
	! - Move toward the encoder index.
	! - Once index is seen, halt
	! - Set the axis origin to the position of index.
	! - Move to the origin. 
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		! AFTER HOMING 0 AND 1, SKIPS THE TRIPOD (AXES 2,3,4), AS IT IS HOMED ABOVE
		IF AXIS_INDEX=2
			AXIS_INDEX=5
		END
		CALL StdHome
		CALL SetLimitMasking		! SETS THE SOFT OR HARD LIMITS
		PTP/e (A_N(AXIS_INDEX)), 0	! MOVE AXIS TO ZERO
		AXIS_INDEX=AXIS_INDEX+1		! INCREMENT AXIS INDEX	
	END

	! IF USER DESIRES, SET VELOCITY AND ACCELERATION
	IF(SETSPEEDVARS=1)
		CALL SetUserVelAcc
	END
	
	! IF ERROR COMP IS ON, MOVE TO INDEX MARKS BEFORE ERROR COMP
	IF ^XYCOMP=0 | ^ZCOMP=0
		AXIS_INDEX=0
		WHILE(AXIS_INDEX < AXIS_QTY)
			PTP (A_N(AXIS_INDEX)), -H_O(AXIS_INDEX)
			AXIS_INDEX=AXIS_INDEX+1
		END
		! WAIT FOR ALL MOTION TO STOP
		AXIS_INDEX=0
		WHILE AXIS_INDEX < AXIS_QTY
			TILL MST(A_N(AXIS_INDEX)).#MOVE=0
			AXIS_INDEX=AXIS_INDEX+1
		END
	END
	WAIT 500

	! ERROR COMPENSATION
	IF XYCOMP=0
		CALL ErrorComp0
	END
	IF XYCOMP=1
		CALL ErrorComp1
	END
	IF ZCOMP=1
		CALL ErrorCompZ1
	END
	IF ZCOMP=2
		CALL ErrorCompZ2
	END

	! MOVE AXES TO ZERO
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		PTP (A_N(AXIS_INDEX)), 0
		AXIS_INDEX=AXIS_INDEX+1
	END
	WAIT 100
	! WAIT FOR ALL MOTION TO STOP
	AXIS_INDEX=0
	WHILE AXIS_INDEX < AXIS_QTY
		TILL MST(A_N(AXIS_INDEX)).#MOVE=0
		AXIS_INDEX=AXIS_INDEX+1
	END

	! START BUFFER 2 -> TRANSITION TO KINEMATICS
	START 2,1
END

IF SYSTYPE=2	! GANTRY
	! GANTRY HOMING
	! - Commutate the motor on axis 0
	! - Move axes 0 and 2 to the left/right end of travel. 
	! - Move back toward the encoder index.
	! - Once index on axis 0 is seen, halt
	! - Set the axis 0 origin to the position of index.
	! - Move axes 0 and 2 toward the left/right end of travel 10mm
	! - Move back toward the encoder index.
	! - Once index on axis 2 is seen, halt
	! - Set the axis 2 origin to the position of index.
	! - Move to the origin.
	CALL GantHome
	PTP/em (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),0,0	! MOVE GANTRY AXES TO ZERO

	! STANDARD HOMING
	! HOMES EACH AXIS THROUGH THE FOLLOWING SEQUENCE (Rotary sequence differs, see note below)
	! - Commutate the motor.
	! - Move to the left/right end of travel. 
	! - Move toward the encoder index.
	! - Once index is seen, halt
	! - Set the axis origin to the position of index.
	! - Move to the origin.
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		! IF THE AXIS IS ONE OF THE GANTRY AXES, THEN SKIP IT
		IF (AXIS_INDEX=GANT_AXES(0) | AXIS_INDEX=GANT_AXES(1))
		ELSE
			CALL StdHome
			CALL SetLimitMasking		! SETS THE SOFT OR HARD LIMITS
			PTP/e (A_N(AXIS_INDEX)), 0	! MOVE TO ZERO
		END
		AXIS_INDEX=AXIS_INDEX+1		! INCREMENT AXIS INDEX	
	END
	
	! IF USER DESIRES, SET VELOCITY AND ACCELERATION
	IF(SETSPEEDVARS=1)
		CALL SetUserVelAcc
	END
	
	! IF ERROR COMP IS ON, MOVE TO INDEX MARKS BEFORE ERROR COMP
	IF ^XYCOMP=0 | ^ZCOMP=0
		AXIS_INDEX=0
		WHILE(AXIS_INDEX < AXIS_QTY)
			IF AXIS_INDEX=GANT_AXES(1)
				!PTP/E (A_N(GANT_AXES(1))), -H_O(GANT_AXES(1))
				!PTP/E (A_N(GANT_AXES(0))), -H_O(GANT_AXES(1))/2
				AXIS_INDEX=AXIS_INDEX+1
			ELSE
				PTP/E (A_N(AXIS_INDEX)), -H_O(AXIS_INDEX)
				AXIS_INDEX=AXIS_INDEX+1
			END
		END
		! WAIT FOR ALL MOTION TO STOP
		AXIS_INDEX=0
		WHILE AXIS_INDEX < AXIS_QTY
			TILL MST(A_N(AXIS_INDEX)).#MOVE=0
			AXIS_INDEX=AXIS_INDEX+1
		END
	END
	WAIT 500
	
	! TURN THE AUTOROUTINES BACK ON
	PFLAGS(2).0=0
	
	! ERROR COMPENSATION
	IF XYCOMP=0
		CALL ErrorComp0
	END
	IF XYCOMP=1
		CALL ErrorComp1
	END
	IF ZCOMP=1
		CALL ErrorCompZ1
	END
	IF ZCOMP=2
		CALL ErrorCompZ2
	END
	
	! MOVE AXES TO ZERO
	AXIS_INDEX=0
	WHILE(AXIS_INDEX < AXIS_QTY)
		PTP (A_N(AXIS_INDEX)), 0
		AXIS_INDEX=AXIS_INDEX+1
	END
	WAIT 100
	! WAIT FOR ALL MOTION TO STOP
	AXIS_INDEX=0
	WHILE AXIS_INDEX < AXIS_QTY
		TILL MST(A_N(AXIS_INDEX)).#MOVE=0
		AXIS_INDEX=AXIS_INDEX+1
	END
END

STOP ! END OF MAIN ROUTINE

! NOTES: 
! - ROTARY HOMING SEQUENCE: THE ROTARY WILL TURN 10DEG IN THE OPPOSITE DIRECTION
!   OF HOMING (HOME_DIR), THEN JOG THE OTHER WAY UNTIL THE INDEX IS SEEN

!!!!!!!!!! USER MODIFIED SUBROUTINES !!!!!!!!!!

SetUserVelAcc:
	! IF STATEMENTS ARE NEEDED FOR THE EVENT OF A CONTROLLER WITH FEW AXES, TO PREVENT ERRORS
	! AXIS 0
	VEL(A_N(0))= 10        	! Set maximum velocity
	ACC(A_N(0))= 100      	! Set acceleration
	DEC(A_N(0))= 100      	! Set deceleration
	JERK(A_N(0))= 1000   	! Set jerk
	KDEC(A_N(0))= 1000     	! Set kill deceleration
	! AXIS 1
	VEL(A_N(1))= 10        	! Set maximum velocity
	ACC(A_N(1))= 100      	! Set acceleration
	DEC(A_N(1))= 100      	! Set deceleration
	JERK(A_N(1))= 1000   	! Set jerk
	KDEC(A_N(1))= 1000    	! Set kill deceleration
	IF (AXIS_QTY>2)
		! AXIS 2
		VEL(A_N(2))= 10        	! Set maximum velocity
		ACC(A_N(2))= 100      	! Set acceleration
		DEC(A_N(2))= 100      	! Set deceleration
		JERK(A_N(2))= 1000   	! Set jerk
		KDEC(A_N(2))= 1000     	! Set kill deceleration
		! AXIS 3
		VEL(A_N(3))= 10        	! Set maximum velocity
		ACC(A_N(3))= 100      	! Set acceleration
		DEC(A_N(3))= 100      	! Set deceleration
		JERK(A_N(3))= 1000   	! Set jerk
		KDEC(A_N(3))= 1000     	! Set kill deceleration	
	END
	IF (AXIS_QTY>4)
		! AXIS 4
		VEL(A_N(4))= 10        	! Set maximum velocity
		ACC(A_N(4))= 100      	! Set acceleration
		DEC(A_N(4))= 100      	! Set deceleration
		JERK(A_N(4))= 1000   	! Set jerk
		KDEC(A_N(4))= 1000     	! Set kill deceleration	
		! AXIS 5
		VEL(A_N(5))= 10        	! Set maximum velocity
		ACC(A_N(5))= 100      	! Set acceleration
		DEC(A_N(5))= 100      	! Set deceleration
		JERK(A_N(5))= 1000   	! Set jerk
		KDEC(A_N(5))= 1000     	! Set kill deceleration	
	END
	IF (AXIS_QTY>6)
		! AXIS 6
		VEL(A_N(6))= 10        	! Set maximum velocity
		ACC(A_N(6))= 100      	! Set acceleration
		DEC(A_N(6))= 100      	! Set deceleration
		JERK(A_N(6))= 1000   	! Set jerk
		KDEC(A_N(6))= 1000     	! Set kill deceleration	
		! AXIS 7
		VEL(A_N(7))= 10        	! Set maximum velocity
		ACC(A_N(7))= 100      	! Set acceleration
		DEC(A_N(7))= 100      	! Set deceleration
		JERK(A_N(7))= 1000   	! Set jerk
		KDEC(A_N(7))= 1000     	! Set kill deceleration	
	END
RET

!!!!!!!!!! END USER MODIFIED SUBROUTINES   !!!!!!!!!!
!!!!!!!!!! START ALIO MODIFIED SUBROUTINES !!!!!!!!!!

ErrorCompTables:
	IF SYSTYPE=0
		ErrorCompXAxis=A_N(STD_AXES(0))
		ErrorCompYAxis=A_N(STD_AXES(1))
		ErrorCompZAxis=A_N(STD_AXES(2))
	END
	IF SYSTYPE=1
		ErrorCompXAxis=0
		ErrorCompYAxis=1
	END
	IF SYSTYPE=2
		ErrorCompXAxis=A_N(GANT_AXES(0))
		ErrorCompYAxis=A_N(GANT_AXES(2))
		ErrorCompZAxis=A_N(GANT_AXES(3))
		ErrorCompZ2Axis=A_N(GANT_AXES(4))
	END
	
	StepX(0) = -500 -H_O(ErrorCompXAxis)
	StepX(1) = -400 -H_O(ErrorCompXAxis)
	StepX(2) = -300 -H_O(ErrorCompXAxis)
	StepX(3) = -200 -H_O(ErrorCompXAxis)
	StepX(4) = -100 -H_O(ErrorCompXAxis)
	StepX(5) = 0 -H_O(ErrorCompXAxis)
	StepX(6) = 100 -H_O(ErrorCompXAxis)
	StepX(7) = 200 -H_O(ErrorCompXAxis)
	StepX(8) = 300 -H_O(ErrorCompXAxis)
	StepX(9) = 400 -H_O(ErrorCompXAxis)
	StepX(10) = 500 -H_O(ErrorCompXAxis)

	StepY(0) = -500 -H_O(ErrorCompYAxis)
	StepY(1) = -400 -H_O(ErrorCompYAxis)
	StepY(2) = -300 -H_O(ErrorCompYAxis)
	StepY(3) = -200 -H_O(ErrorCompYAxis)
	StepY(4) = -100 -H_O(ErrorCompYAxis)
	StepY(5) = 0 -H_O(ErrorCompYAxis)
	StepY(6) = 100 -H_O(ErrorCompYAxis)
	StepY(7) = 200 -H_O(ErrorCompYAxis)
	StepY(8) = 300 -H_O(ErrorCompYAxis)
	StepY(9) = 400 -H_O(ErrorCompYAxis)
	StepY(10) = 500 -H_O(ErrorCompYAxis)
	
	XStepY(0)=-400 -H_O(ErrorCompYAxis)
	XStepY(1)=0 -H_O(ErrorCompYAxis)
	XStepY(2)=400 -H_O(ErrorCompYAxis)

	YStepX(0)=-400 -H_O(ErrorCompXAxis)
	YStepX(1)=0 -H_O(ErrorCompXAxis)
	YStepX(2)=400 -H_O(ErrorCompXAxis)
	
	! LDA
	LdaX(0)(0) = 0.85
	LdaX(0)(1) = -2.05
	LdaX(0)(2) = 3.45
	LdaX(0)(3) = 6.25
	LdaX(0)(4) = 1.85
	LdaX(0)(5) = 3.15
	LdaX(0)(6) = 6.7
	LdaX(0)(7) = 6.3
	LdaX(0)(8) = 2.1
	LdaX(0)(9) = 4.8
	LdaX(0)(10) = 11.25
	
	LdaX(1)(0) = 0.85
	LdaX(1)(1) = -2.05
	LdaX(1)(2) = 3.45
	LdaX(1)(3) = 6.25
	LdaX(1)(4) = 1.85
	LdaX(1)(5) = 3.15
	LdaX(1)(6) = 6.7
	LdaX(1)(7) = 6.3
	LdaX(1)(8) = 2.1
	LdaX(1)(9) = 4.8
	LdaX(1)(10) = 11.25
	
	LdaX(2)(0) = 0.85
	LdaX(2)(1) = -2.05
	LdaX(2)(2) = 3.45
	LdaX(2)(3) = 6.25
	LdaX(2)(4) = 1.85
	LdaX(2)(5) = 3.15
	LdaX(2)(6) = 6.7
	LdaX(2)(7) = 6.3
	LdaX(2)(8) = 2.1
	LdaX(2)(9) = 4.8
	LdaX(2)(10) = 11.25
	
	LdaY(0)(0) = -14.05
	LdaY(0)(1) = -17.1
	LdaY(0)(2) = -16.4
	LdaY(0)(3) = -12.85
	LdaY(0)(4) = -12.15
	LdaY(0)(5) = -13.9
	LdaY(0)(6) = -12.2
	LdaY(0)(7) = -11.75
	LdaY(0)(8) = -10.8
	LdaY(0)(9) = -7.2
	LdaY(0)(10) = -5.05
	
	LdaY(1)(0) = -14.05
	LdaY(1)(1) = -17.1
	LdaY(1)(2) = -16.4
	LdaY(1)(3) = -12.85
	LdaY(1)(4) = -12.15
	LdaY(1)(5) = -13.9
	LdaY(1)(6) = -12.2
	LdaY(1)(7) = -11.75
	LdaY(1)(8) = -10.8
	LdaY(1)(9) = -7.2
	LdaY(1)(10) = -5.05
	
	LdaY(2)(0) = -14.05
	LdaY(2)(1) = -17.1
	LdaY(2)(2) = -16.4
	LdaY(2)(3) = -12.85
	LdaY(2)(4) = -12.15
	LdaY(2)(5) = -13.9
	LdaY(2)(6) = -12.2
	LdaY(2)(7) = -11.75
	LdaY(2)(8) = -10.8
	LdaY(2)(9) = -7.2
	LdaY(2)(10) = -5.05
	
	!!!IMPORTANT!!! IF APPLYING LDA AND STRAIGHTNESS COMPENSATIONS, ENSURE STRAIGHTNESS COMP IS APPLIED BEFORE LDA MEASUREMENTS.
	StrX(0)(0) = -68.550
	StrX(0)(1) = -49.400
	StrX(0)(2) = -32.600
	StrX(0)(3) = -21.25
	StrX(0)(4) = -9.2
	StrX(0)(5) = 0
	StrX(0)(6) = 3.75
	StrX(0)(7) = -1.35
	StrX(0)(8) = -19.35
	StrX(0)(9) = -52.30
	StrX(0)(10) = -68.55
	             
	StrX(1)(0) = -68.550
	StrX(1)(1) = -49.400
	StrX(1)(2) = -32.600
	StrX(1)(3) = -21.25
	StrX(1)(4) = -9.2
	StrX(1)(5) = 0
	StrX(1)(6) = 3.75
	StrX(1)(7) = -1.35
	StrX(1)(8) = -19.35
	StrX(1)(9) = -52.30
	StrX(1)(10) = -68.55
	             
	StrX(2)(0) = -68.550
	StrX(2)(1) = -49.400
	StrX(2)(2) = -32.600
	StrX(2)(3) = -21.25
	StrX(2)(4) = -9.2
	StrX(2)(5) = 0
	StrX(2)(6) = 3.75
	StrX(2)(7) = -1.35
	StrX(2)(8) = -19.35
	StrX(2)(9) = -52.30
	StrX(2)(10) = -68.55
	             
	StrY(0)(0) = 131.525
	StrY(0)(1) = 111.25
	StrY(0)(2) = 82.125
	StrY(0)(3) = 39.25
	StrY(0)(4) = 16.325
	StrY(0)(5) = 0
	StrY(0)(6) = -23.525
	StrY(0)(7) = 10.75
	StrY(0)(8) = 71.025
	StrY(0)(9) = 105.75
	StrY(0)(10) = 131.525
	             
	StrY(1)(0) = 131.525
	StrY(1)(1) = 111.25
	StrY(1)(2) = 82.125
	StrY(1)(3) = 39.25
	StrY(1)(4) = 16.325
	StrY(1)(5) = 0
	StrY(1)(6) = -23.525
	StrY(1)(7) = 10.75
	StrY(1)(8) = 71.025
	StrY(1)(9) = 105.75
	StrY(1)(10) = 131.525
                 
	StrY(2)(0) = 131.525
	StrY(2)(1) = 111.25
	StrY(2)(2) = 82.125
	StrY(2)(3) = 39.25
	StrY(2)(4) = 16.325
	StrY(2)(5) = 0
	StrY(2)(6) = -23.525
	StrY(2)(7) = 10.75
	StrY(2)(8) = 71.025
	StrY(2)(9) = 105.75
	StrY(2)(10) = 131.525
	
	T_1 = 0			! in RADIANS; T_1=ATAN((d0-d1)/d), + rotates +/+ plot CCW, - rotates +/+ plot CW
	
	FlatX(0)(0) = 4
	FlatX(0)(1) = 3
	FlatX(0)(2) = 2
	FlatX(0)(3) = 3
	FlatX(0)(4) = 3
	FlatX(0)(5) = 0
	FlatX(0)(6) = -4
	FlatX(0)(7) = -5
	FlatX(0)(8) = -5
	FlatX(0)(9) = -3
	FlatX(0)(10) = -3

	FlatX(1)(0) = 4
	FlatX(1)(1) = 3
	FlatX(1)(2) = 2
	FlatX(1)(3) = 3
	FlatX(1)(4) = 3
	FlatX(1)(5) = 0
	FlatX(1)(6) = -4
	FlatX(1)(7) = -5
	FlatX(1)(8) = -5
	FlatX(1)(9) = -3
	FlatX(1)(10) = -3
	
	FlatX(2)(0) = 4
	FlatX(2)(1) = 3
	FlatX(2)(2) = 2
	FlatX(2)(3) = 3
	FlatX(2)(4) = 3
	FlatX(2)(5) = 0
	FlatX(2)(6) = -4
	FlatX(2)(7) = -5
	FlatX(2)(8) = -5
	FlatX(2)(9) = -3
	FlatX(2)(10) = -3
	
	FlatY(0)(0) = 173
	FlatY(0)(1) = 131
	FlatY(0)(2) = 98
	FlatY(0)(3) = 71
	FlatY(0)(4) = 33
	FlatY(0)(5) = 0
	FlatY(0)(6) = -28
	FlatY(0)(7) = -93
	FlatY(0)(8) = -130
	FlatY(0)(9) = -151
	FlatY(0)(10) = -208
				
	FlatY(1)(0) = 173
	FlatY(1)(1) = 131
	FlatY(1)(2) = 98
	FlatY(1)(3) = 71
	FlatY(1)(4) = 33
	FlatY(1)(5) = 0
	FlatY(1)(6) = -28
	FlatY(1)(7) = -93
	FlatY(1)(8) = -130
	FlatY(1)(9) = -151
	FlatY(1)(10) = -208
				
	FlatY(2)(0) = 173
	FlatY(2)(1) = 131
	FlatY(2)(2) = 98
	FlatY(2)(3) = 71
	FlatY(2)(4) = 33
	FlatY(2)(5) = 0
	FlatY(2)(6) = -28
	FlatY(2)(7) = -93
	FlatY(2)(8) = -130
	FlatY(2)(9) = -151
	FlatY(2)(10) = -208
	
	! Second z tables for flatness
	FlatX2(0)(0) = 0
	FlatX2(0)(1) = 0
	FlatX2(0)(2) = 0
	FlatX2(0)(3) = 0
	FlatX2(0)(4) = 0
	FlatX2(0)(5) = 0
	FlatX2(0)(6) = 0
	FlatX2(0)(7) = 0
	FlatX2(0)(8) = 0
	FlatX2(0)(9) = 0
	FlatX2(0)(10) = 0
	
	FlatX2(1)(0) = 0
	FlatX2(1)(1) = 0
	FlatX2(1)(2) = 0
	FlatX2(1)(3) = 0
	FlatX2(1)(4) = 0
	FlatX2(1)(5) = 0
	FlatX2(1)(6) = 0
	FlatX2(1)(7) = 0
	FlatX2(1)(8) = 0
	FlatX2(1)(9) = 0
	FlatX2(1)(10) = 0
	
	FlatX2(2)(0) = 0
	FlatX2(2)(1) = 0
	FlatX2(2)(2) = 0
	FlatX2(2)(3) = 0
	FlatX2(2)(4) = 0
	FlatX2(2)(5) = 0
	FlatX2(2)(6) = 0
	FlatX2(2)(7) = 0
	FlatX2(2)(8) = 0
	FlatX2(2)(9) = 0
	FlatX2(2)(10) = 0
	
	FlatY2(0)(0) = 175
	FlatY2(0)(1) = 168
	FlatY2(0)(2) = 118
	FlatY2(0)(3) = 78
	FlatY2(0)(4) = 55
	FlatY2(0)(5) = 0
	FlatY2(0)(6) = -40
	FlatY2(0)(7) = -76
	FlatY2(0)(8) = -112
	FlatY2(0)(9) = -134
	FlatY2(0)(10) = -180
		 
	FlatY2(1)(0) = 175
	FlatY2(1)(1) = 168
	FlatY2(1)(2) = 118
	FlatY2(1)(3) = 78
	FlatY2(1)(4) = 55
	FlatY2(1)(5) = 0
	FlatY2(1)(6) = -40
	FlatY2(1)(7) = -76
	FlatY2(1)(8) = -112
	FlatY2(1)(9) = -134
	FlatY2(1)(10) = -180
				 
	FlatY2(2)(0) = 175
	FlatY2(2)(1) = 168
	FlatY2(2)(2) = 118
	FlatY2(2)(3) = 78
	FlatY2(2)(4) = 55
	FlatY2(2)(5) = 0
	FlatY2(2)(6) = -40
	FlatY2(2)(7) = -76
	FlatY2(2)(8) = -112
	FlatY2(2)(9) = -134
	FlatY2(2)(10) = -180
	
	! XY Yaw tables
	YawX(0) = -20.540
	YawX(1) = -23.783
	YawX(2) = -13.222
	YawX(3) = -1.850
	YawX(4) = -5.676
	YawX(5) = 0
	YawX(6) = 16.320
	YawX(7) = 36.236
	YawX(8) = 40.748
	YawX(9) = 37.525
	YawX(10) = 47.400
	
	YawY(0) = 533.876
	YawY(1) = 519.968
	YawY(2) = 456.851
	YawY(3) = 342.965
	YawY(4) = 143.822
	YawY(5) = 0
	YawY(6) = -213.239
	YawY(7) = -594.249
	YawY(8) = -936.092
	YawY(9) = -1131.244
	YawY(10) = -1203.404
	
	GANT_ORTHO = 0		! in mm - Gantry Yaw
	
	!!!! Z COMPENSATION !!!!
	StepZ(0) = -100 -H_O(ErrorCompZAxis)
	StepZ(1) = -80 -H_O(ErrorCompZAxis)
	StepZ(2) = -60 -H_O(ErrorCompZAxis)
	StepZ(3) = -40 -H_O(ErrorCompZAxis)
	StepZ(4) = -20 -H_O(ErrorCompZAxis)
	StepZ(5) = 0 -H_O(ErrorCompZAxis)
	StepZ(6) = 20 -H_O(ErrorCompZAxis)
	StepZ(7) = 40 -H_O(ErrorCompZAxis)
	StepZ(8) = 60 -H_O(ErrorCompZAxis)
	StepZ(9) = 80 -H_O(ErrorCompZAxis)
	StepZ(10) = 100 -H_O(ErrorCompZAxis)
	
	! LdaZ USED IN SYSTYPE=0, ZCOMP=1
	LdaZ(0) = 12.606
	LdaZ(1) = 10.451
	LdaZ(2) = 8.105
	LdaZ(3) = 5.204
	LdaZ(4) = 2.900
	LdaZ(5) = 0
	LdaZ(6) = -3.461
	LdaZ(7) = -7.098
	LdaZ(8) = -10.870
	LdaZ(9) = -15.764
	LdaZ(10) = -19.346
	
	! Second Z LDA comp
	StepZ2(0) = -100 -H_O(ErrorCompZ2Axis)
	StepZ2(1) = -80 -H_O(ErrorCompZ2Axis)
	StepZ2(2) = -60 -H_O(ErrorCompZ2Axis)
	StepZ2(3) = -40 -H_O(ErrorCompZ2Axis)
	StepZ2(4) = -20 -H_O(ErrorCompZ2Axis)
	StepZ2(5) = 0 -H_O(ErrorCompZ2Axis)
	StepZ2(6) = 20 -H_O(ErrorCompZ2Axis)
	StepZ2(7) = 40 -H_O(ErrorCompZ2Axis)
	StepZ2(8) = 60 -H_O(ErrorCompZ2Axis)
	StepZ2(9) = 80 -H_O(ErrorCompZ2Axis)
	StepZ2(10) = 100 -H_O(ErrorCompZ2Axis)
	
	LdaZ2(0) = 5.618
	LdaZ2(1) = 4.735
	LdaZ2(2) = 3.538
	LdaZ2(3) = 2.397
	LdaZ2(4) = 1.274
	LdaZ2(5) = 0
	LdaZ2(6) = -2.220
	LdaZ2(7) = -4.647
	LdaZ2(8) = -7.475
	LdaZ2(9) = -10.590
	LdaZ2(10) = -13.047
	!!!! END Z COMPENSATION !!!!
	
RET

! TUNING SUBROUTINES
TuningParameters: 
	! SET TUNING PARAMETERS FOR AXES 0, 2
	SLPKP(A_N(GANT_AXES(0)))=10
	SLVKP(A_N(GANT_AXES(0)))=40
	SLVKI(A_N(GANT_AXES(0)))=200
	SLVSOF(A_N(GANT_AXES(0)))=700	! Low pass filter bandwidth
	MFLAGS(A_N(GANT_AXES(0))).14=0	! Notch Filter off (0=OFF, 1=ON)
	!SLVNATT(A_N(GANT_AXES(0)))=2
	!SLVNFRQ(A_N(GANT_AXES(0)))=410
	!SLVNWID(A_N(GANT_AXES(0)))=100
	MFLAGS(A_N(GANT_AXES(0))).16=0	! First Biquad filter (0=OFF, 1=ON)
	!SLVB0DD(A_N(GANT_AXES(0)))=0.5
	!SLVB0DF(A_N(GANT_AXES(0)))=400
	!SLVB0ND(A_N(GANT_AXES(0)))=0.1
	!SLVB0NF(A_N(GANT_AXES(0)))=500
	MFLAGS(A_N(GANT_AXES(0))).26=0	! Second Biquad filter (0=OFF, 1=ON)
	!SLVB1DD(A_N(GANT_AXES(0)))=0.5
	!SLVB1DF(A_N(GANT_AXES(0)))=450
	!SLVB1ND(A_N(GANT_AXES(0)))=0.1
	!SLVB1NF(A_N(GANT_AXES(0)))=500
	
	SLPKP(A_N(GANT_AXES(1)))=10
	SLVKP(A_N(GANT_AXES(1)))=40
	SLVKI(A_N(GANT_AXES(1)))=200
	SLVSOF(A_N(GANT_AXES(1)))=700	! Low pass filter bandwidth
	MFLAGS(A_N(GANT_AXES(1))).14=0	! Notch Filter off (0=OFF, 1=ON)
	!SLVNATT(A_N(GANT_AXES(1)))=2
	!SLVNFRQ(A_N(GANT_AXES(1)))=410
	!SLVNWID(A_N(GANT_AXES(1)))=100
	MFLAGS(A_N(GANT_AXES(1))).16=0	! First Biquad filter (0=OFF, 1=ON)
	!SLVB0DD(A_N(GANT_AXES(1)))=0.5
	!SLVB0DF(A_N(GANT_AXES(1)))=450
	!SLVB0ND(A_N(GANT_AXES(1)))=0.1
	!SLVB0NF(A_N(GANT_AXES(1)))=500
	MFLAGS(A_N(GANT_AXES(1))).26=0	! Second Biquad filter (0=OFF, 1=ON)
	!SLVB1DD(A_N(GANT_AXES(1)))=0.5
	!SLVB1DF(A_N(GANT_AXES(1)))=450
	!SLVB1ND(A_N(GANT_AXES(1)))=0.1
	!SLVB1NF(A_N(GANT_AXES(1)))=500
RET

TuningParametersGantry:
	! SET TUNING PARAMETERS FOR GANTRY YAW and X
	SLPKP(A_N(GANT_AXES(0)))=50
	SLVKP(A_N(GANT_AXES(0)))=80
	SLVKI(A_N(GANT_AXES(0)))=200
	SLVSOF(A_N(GANT_AXES(0)))=700	! Low pass filter bandwidth
	MFLAGS(A_N(GANT_AXES(0))).14=0	! Notch Filter off (0=OFF, 1=ON)
	SLVNATT(A_N(GANT_AXES(0)))=2
	SLVNFRQ(A_N(GANT_AXES(0)))=410
	SLVNWID(A_N(GANT_AXES(0)))=100
	MFLAGS(A_N(GANT_AXES(0))).16=0	! First Biquad filter (0=OFF, 1=ON)
	SLVB0DD(A_N(GANT_AXES(0)))=0.5
	SLVB0DF(A_N(GANT_AXES(0)))=450
	SLVB0ND(A_N(GANT_AXES(0)))=0.1
	SLVB0NF(A_N(GANT_AXES(0)))=600
	MFLAGS(A_N(GANT_AXES(0))).26=0	! Second Biquad filter (0=OFF, 1=ON)
	!SLVB1DD(A_N(GANT_AXES(0)))=0.5
	!SLVB1DF(A_N(GANT_AXES(0)))=450
	!SLVB1ND(A_N(GANT_AXES(0)))=0.1
	!SLVB1NF(A_N(GANT_AXES(0)))=500
	
	SLPKP(A_N(GANT_AXES(1)))=50
	SLVKP(A_N(GANT_AXES(1)))=8
	SLVKI(A_N(GANT_AXES(1)))=200
	SLVSOF(A_N(GANT_AXES(1)))=700	! Low pass filter bandwidth
	MFLAGS(A_N(GANT_AXES(1))).14=0	! Notch Filter off (0=OFF, 1=ON)
	SLVNATT(A_N(GANT_AXES(1)))=2
	SLVNFRQ(A_N(GANT_AXES(1)))=794
	SLVNWID(A_N(GANT_AXES(1)))=100
	MFLAGS(A_N(GANT_AXES(1))).16=0	! First Biquad filter (0=OFF, 1=ON)
	SLVB0DD(A_N(GANT_AXES(1)))=0.5
	SLVB0DF(A_N(GANT_AXES(1)))=450
	SLVB0ND(A_N(GANT_AXES(1)))=0.1
	SLVB0NF(A_N(GANT_AXES(1)))=600
	MFLAGS(A_N(GANT_AXES(1))).26=0	! Second Biquad filter (0=OFF, 1=ON)
	!SLVB1DD(A_N(GANT_AXES(1)))=0.5
	!SLVB1DF(A_N(GANT_AXES(1)))=450
	!SLVB1ND(A_N(GANT_AXES(1)))=0.1
	!SLVB1NF(A_N(GANT_AXES(1)))=500
RET

!!!!!!!!!! END ALIO MODIFIED SUBROUTINES !!!!!!!!!!

!!!!!!!!!! OTHER SUBROUTINES !!!!!!!!!!
Initialize:
	UpdateUPOS=0
	UpdateUPOS=1
	
	DISABLE ALL		! DISABLE ALL AXES
	SPLIT ALL		! ADDED TO ENSURE THAT ALL GROUPED AXES ARE RESET WHEN HOMING IS RUN (ISSUE WITH DMC APPLICATION)
	
	
	! RESETS THE E_TYPE FOR GANTRY AXES, NEEDED IF THERE IS AN ENCODER ERROR
	! - THIS IS RELATED TO THE ENCODER ERROR SEEN WITH HEIDENHAIN ENCODERS
	IF SYSTYPE=2
		E_TYPE(A_N(GANT_AXES(0)))=E_TYPE(A_N(GANT_AXES(0)))
		E_TYPE(A_N(GANT_AXES(1)))=E_TYPE(A_N(GANT_AXES(1)))
		MFLAGS(A_N(GANT_AXES(0))).9=0
		MFLAGS(A_N(GANT_AXES(1))).9=0
	END
	
	! SET HOMING VELOCITIES AND ACCELERATIONS
	AXIS_INDEX=0   ! SET THE AXIS_INDEX
	WHILE(AXIS_INDEX < AXIS_QTY)
		IF(AXIS_HOME(AXIS_INDEX)=1)
			HOME_FLAG(AXIS_INDEX)=0;
		END
		VEL(A_N(AXIS_INDEX))=VELOCITY(AXIS_INDEX)  !SET THE MAX VELOCITY
		ACC(A_N(AXIS_INDEX))=10*VEL(A_N(AXIS_INDEX))    !SET THE ACCELERATION
		DEC(A_N(AXIS_INDEX))=10*VEL(A_N(AXIS_INDEX))    !SET THE DECELERATION
		JERK(A_N(AXIS_INDEX))=100*VEL(A_N(AXIS_INDEX))  !SET THE JERK
		KDEC(A_N(AXIS_INDEX))=100*VEL(A_N(AXIS_INDEX))  !SET THE KILL DECELERATION
		IF(MFLAGS(A_N(AXIS_INDEX)).17=0)
			CONNECT RPOS(A_N(AXIS_INDEX))=APOS(A_N(AXIS_INDEX))
		END
		MFLAGS(A_N(AXIS_INDEX)).17=1	!TURN OFF COMPENSATION TABLES
		IF (AXIS_LIMITS(AXIS_INDEX)=2)		!NEEDED TO PREVENT OVERCURRENT DURING NO LIMITS HOMING
			ACC(A_N(AXIS_INDEX))=10*ACC(A_N(AXIS_INDEX))
			DEC(A_N(AXIS_INDEX))=10*DEC(A_N(AXIS_INDEX))
			JERK(A_N(AXIS_INDEX))=10*JERK(A_N(AXIS_INDEX))
			KDEC(A_N(AXIS_INDEX))=10*KDEC(A_N(AXIS_INDEX))
		END
		AXIS_INDEX=AXIS_INDEX+1               !INCREMENT THE AXIS_INDEX
	END
RET

COMM_AND_FLAGS:
	! TURN OFF SOFT LIMITS FOR HOMING	
	FMASK(A_N(AXIS_INDEX)).5=0   ! MASK SOFTWARE RIGHT LIMIT	
	FMASK(A_N(AXIS_INDEX)).6=0	! MASK SOFTWARE LEFT LIMIT
	! TURN ON HARDWARE LIMITS FOR HOMING	
	FMASK(A_N(AXIS_INDEX)).0=1	! ACTIVATE RIGHT LIMIT
	FMASK(A_N(AXIS_INDEX)).1=1	! ACTIVATE LEFT LIMIT	
	! TURN OFF DEFAULT RESPONSE FOR HARDWARE LIMITS		
	FDEF(A_N(AXIS_INDEX)).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(AXIS_INDEX)).#RL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE		
	
	BLOCK
	ENABLE (A_N(AXIS_INDEX))      	! ENABLE THE AXIS 
	!TILL MST(A_N(AXIS_INDEX)).#ENABLED=1
	!WAIT 100
	
	IF MFLAGS(A_N(AXIS_INDEX)).9=0;
		IF(COMMUT_ON(AXIS_INDEX)=1)   !IF COMMUTATION IS SELECTED FOR AXIS
			MFLAGS(A_N(AXIS_INDEX)).9=0
			COMMUT (A_N(AXIS_INDEX)), (COMMUT_EXCITATION(AXIS_INDEX)), 1000
			TILL MFLAGS(A_N(AXIS_INDEX)).9=1, 5000
		END
	END
	END
RET
	
TripodHome: ! HOMING ROUTINE FOR THE TRIPOD (ASSUMES THE TRIPOD AXES ARE 2,3,4 AT THE MOMENT)
	AXIS_INDEX=2   !RESET THE AXIS INDEX
	LOOP 3
		! TURN OFF SOFT LIMITS FOR HOMING	
		FMASK(A_N(AXIS_INDEX)).5=0    ! MASK SOFTWARE RIGHT LIMIT
		FMASK(A_N(AXIS_INDEX)).6=0	! MASK SOFTWARE LEFT LIMIT
		! TURN ON HARDWARE LIMITS FOR HOMING	
		FMASK(A_N(AXIS_INDEX)).0=1	! ACTIVATE RIGHT LIMIT
		FMASK(A_N(AXIS_INDEX)).1=1	! ACTIVATE LEFT LIMIT	
		! TURN OFF DEFAULT RESPONSE FOR HARDWARE LIMITS		
		FDEF(A_N(AXIS_INDEX)).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
		FDEF(A_N(AXIS_INDEX)).#RL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		
		ENABLE (A_N(AXIS_INDEX))      	! ENABLE THE AXIS 
		WAIT 500

		IF MFLAGS(A_N(AXIS_INDEX)).9=0;
			IF(COMMUT_ON(AXIS_INDEX)=1)   !IF COMMUTATION IS SELECTED FOR AXIS
				MFLAGS(A_N(AXIS_INDEX)).9=0
				COMMUT (A_N(AXIS_INDEX)), (COMMUT_EXCITATION(AXIS_INDEX)),1000 
				TILL MFLAGS(A_N(AXIS_INDEX)).9=1, 5000
			END
		END
		AXIS_INDEX=AXIS_INDEX+1               !INCREMENT THE AXIS_INDEX

	END	! END LOOP

	IF (HOME_DIR(2)=-1 & HOME_DIR(3)=-1 & HOME_DIR(4)=-1) ! IF AXES 2, 3 AND 4 ARE SET TO HOME DOWN
		JOG A_N(2), -; JOG A_N(3), -; JOG A_N(4), -; ! JOG ALL THREE AXES DOWN
		WHILE ((^FAULT(A_N(2)).#LL)+(^FAULT(A_N(3)).#LL)+(^FAULT(A_N(4)).#LL)<>0)	! UNTIL ALL TRI AXES ARE AT THE LOWER LIMIT
			BLOCK
				IF FAULT(A_N(2)).#LL	! WAIT FOR THE AXIS 2 LEFT LIMIT SWITCH ACTIVATION
					HALT A_N(2)
				END
				IF FAULT(A_N(3)).#LL	! WAIT FOR THE AXIS 3 LEFT LIMIT SWITCH ACTIVATION
					HALT A_N(3)
				END
				IF FAULT(A_N(4)).#LL	! WAIT FOR THE AXIS 4 LEFT LIMIT SWITCH ACTIVATION
					HALT A_N(4)
				END
			END
		END
		HALT (A_N(2),A_N(3),A_N(4))
	  
		WAIT 500
	 
		JOG A_N(2), +; JOG A_N(3), +; JOG A_N(4), +; ! JOG ALL THREE AXES UP
		TILL ((FAULT(A_N(2)).#LL)+(FAULT(A_N(3)).#LL)+(FAULT(A_N(4)).#LL)=0)	! WAIT TO PROCEED UNTIL ALL LOWER LIMIT SWITCHES HAVE RELEASED	
	END ! END HOMING DOWN
	 
	IF (HOME_DIR(2)=1 & HOME_DIR(3)=1 & HOME_DIR(4)=1) ! IF AXES 2, 3 AND 4 ARE SET TO HOME UP
		JOG A_N(2), +; JOG A_N(3), +; JOG A_N(4), +; ! JOG ALL THREE AXES UP
		WHILE ((^FAULT(A_N(2)).#RL)+(^FAULT(A_N(3)).#RL)+(^FAULT(A_N(4)).#RL)<>0)	! UNTIL ALL TRI AXES ARE AT THE UPPER LIMIT
			BLOCK
				IF FAULT(A_N(2)).#RL	! WAIT FOR THE AXIS 2 RIGHT LIMIT SWITCH ACTIVATION
					HALT A_N(2)
				END
				IF FAULT(A_N(3)).#RL	! WAIT FOR THE AXIS 3 RIGHT LIMIT SWITCH ACTIVATION
					HALT A_N(3)
				END
				IF FAULT(A_N(4)).#RL	! WAIT FOR THE AXIS 4 RIGHT LIMIT SWITCH ACTIVATION
					HALT A_N(4)
				END
			END
		END
		HALT (A_N(2),A_N(3),A_N(4))
	 
		WAIT 500
	 
		JOG A_N(2), -; JOG A_N(3), -; JOG A_N(4), -; ! JOG ALL THREE AXES DOWN
		TILL ((FAULT(A_N(2)).#RL)+(FAULT(A_N(3)).#RL)+(FAULT(A_N(4)).#RL)=0)	! WAIT TO PROCEED UNTIL ALL UPPER LIMIT SWITCHES HAVE RELEASED	
	END ! END HOMING UP
	 
	IF ((HOME_DIR(2)<>HOME_DIR(3)) | (HOME_DIR(3)<>HOME_DIR(4)=1)) ! IF THE 3 AXES HOME DIRECTIONs DO NOT MATCH
		STOP ! STOP CODE EXECUTION
	END

	IST(A_N(2)).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)
	IST(A_N(3)).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)
	IST(A_N(4)).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)
	IST(A_N(2)).#IND=0       	! RESET THE INDEX FLAG BIT
	IST(A_N(3)).#IND=0       	! RESET THE INDEX FLAG BIT
	IST(A_N(4)).#IND=0       	! RESET THE INDEX FLAG BIT

	WHILE ((^IST(A_N(2)).#IND)+(^IST(A_N(3)).#IND)+(^IST(A_N(4)).#IND)<>0) ! WHILE ALL 3 AXES ARE NOT INDEXED
		BLOCK
			IF IST(A_N(2)).#IND	! WAIT FOR THE AXIS 2 INDEX ACTIVATION
				HALT A_N(2)
			END
			IF IST(A_N(3)).#IND	! WAIT FOR THE AXIS 3 INDEX ACTIVATION
				HALT A_N(3)
			END
			IF IST(A_N(4)).#IND	! WAIT FOR THE AXIS 4 INDEX ACTIVATION
				HALT A_N(4)
			END
		END
	END
	HALT (A_N(2),A_N(3),A_N(4))
	 
	IF (HOME_DIGITAL(2))=0	! IF AXIS IS ANALOG (LOGIC IS ASSUMING ALL 3 AXES HAVE THE SAME INTERFACE)
		PTP(A_N(2)), IND(A_N(2)) + POW(2,(E_SCMUL(A_N(2))-3))*EFAC(A_N(2))	! Move to a middle of a quadrant, close to the index location
		TILL ^MST(A_N(2)).#MOVE, 30000
		WAIT 1000
		SET FPOS(A_N(2)) = FPOS(A_N(2)) - IND(A_N(2)) - GETCONF(265,A_N(2))-H_O(2)	! Repeatability correction
		   
		PTP(A_N(3)), IND(A_N(3)) + POW(2,(E_SCMUL(A_N(3))-3))*EFAC(A_N(3))	! Move to a middle of a quadrant, close to the index location
		TILL ^MST(A_N(3)).#MOVE, 30000
		WAIT 1000
		SET FPOS(A_N(3)) = FPOS(A_N(3)) - IND(A_N(3)) - GETCONF(265,A_N(3))-H_O(3)	! Repeatability correction
		
		PTP(A_N(4)), IND(A_N(4)) + POW(2,(E_SCMUL(A_N(4))-3))*EFAC(A_N(4))	! Move to a middle of a quadrant, close to the index location
		TILL ^MST(A_N(4)).#MOVE, 30000
		WAIT 1000
		SET FPOS(A_N(4)) = FPOS(A_N(4)) - IND(A_N(4)) - GETCONF(265,A_N(4))-H_O(4)	! Repeatability correction
	END

	IF (HOME_DIGITAL(A_N(2)))=1	! IF AXIS IS DIGITAL (LOGIC IS ASSUMING ALL 3 AXES HAVE THE SAME INTERFACE)
		SET FPOS(A_N(2))=FPOS(A_N(2))-IND(A_N(2))-H_O(2)  ! Set axis origin to the position of index = zero
		SET FPOS(A_N(3))=FPOS(A_N(3))-IND(A_N(3))-H_O(3)  ! Set axis origin to the position of index = zero
		SET FPOS(A_N(4))=FPOS(A_N(4))-IND(A_N(4))-H_O(4)  ! Set axis origin to the position of index = zero
		WAIT 1000
	END

	PTP/E (A_N(2),A_N(3),A_N(4)), 0, 0, 0 ! MOVE ALL 3 AXES TO THE 0 LOCATIONS

	HOME_FLAG(A_N(2))=1;			! SET HOME FLAG COMPLETE
	HOME_FLAG(A_N(3))=1;			! SET HOME FLAG COMPLETE
	HOME_FLAG(A_N(4))=1;			! SET HOME FLAG COMPLETE
	 
	BLOCK
		FDEF(A_N(2)).#LL=1       	! ENABLE THE LEFT LIMIT DEFAULT RESPONSE				
		FDEF(A_N(2)).#RL=1       	! ENABLE THE RIGHT LIMIT DEFAULT RESPONSE				
		FMASK(A_N(2)).#SRL=1		! TURN ON SOFTWARE RIGHT LIMIT		
		FMASK(A_N(2)).#SLL=1		! TURN ON SOFTWARE LEFT LIMIT	
		
		FDEF(A_N(3)).#LL=1       	! ENABLE THE LEFT LIMIT DEFAULT RESPONSE				
		FDEF(A_N(3)).#RL=1       	! ENABLE THE RIGHT LIMIT DEFAULT RESPONSE				
		FMASK(A_N(3)).#SRL=1		! TURN ON SOFTWARE RIGHT LIMIT		
		FMASK(A_N(3)).#SLL=1		! TURN ON SOFTWARE LEFT LIMIT
		
		FDEF(A_N(4)).#LL=1       	! ENABLE THE LEFT LIMIT DEFAULT RESPONSE				
		FDEF(A_N(4)).#RL=1       	! ENABLE THE RIGHT LIMIT DEFAULT RESPONSE				
		FMASK(A_N(4)).#SRL=1		! TURN ON SOFTWARE RIGHT LIMIT		
		FMASK(A_N(4)).#SLL=1		! TURN ON SOFTWARE LEFT LIMIT
	END	! END BLOCK
RET

StdHome: ! STANDARD HOMING
	
	CALL COMM_AND_FLAGS

	IF(AXIS_HOME(AXIS_INDEX)=1)
		! HOMING ROUTINE FOR ROTARY WITHOUT LIMITS
		IF(AXIS_LIMITS(AXIS_INDEX)=0)   ! IF AXIS DOES NOT HAVE LIMITS
			CALL RotNoLimHome
		END
		! HOMING ROUTINE FOR LINEAR WITH LIMITS				
		IF(AXIS_LIMITS(AXIS_INDEX)=1)               ! IF FOR AXIS WITH LIMITS
			CALL LinWithLimHome
		END
		! HOMING ROUTINE FOR LINEAR WITHOUT LIMITS				
		IF(AXIS_LIMITS(AXIS_INDEX)=2)               ! IF FOR AXIS WITH LIMITS
			CALL LinNoLimHome
		END
		! SET HOME POSITION
		IST(A_N(AXIS_INDEX)).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)					
		IST(A_N(AXIS_INDEX)).#IND=0       	! RESET THE INDEX FLAG BIT				
		TILL IST(A_N(AXIS_INDEX)).#IND, 60000    	! WAIT FOR INDEX READ
	 
		!***********************
		! NOTE THE SECTION BETWEEN THE "*"'S IS THE CODE THAT IS NECESSARY TO HAVE 
		! WHEN HOMING A SIN/COS ENCODER.  THIS CODE WAS PROVIDED BY ACS PER A TECH 
		! SUPPORT NOTE TO RESOLVE AN ISSUE WHERE HOMING WOULD NOT BE REPEATABLE 
		! BECAUSE IT WOULD NOT HOME TO THE SAME QUADRANT OF THE SIN/COS 20UM CYCLE
		! THUS HOMING REPEATABILITY COULD BE 5UM OR WORSE.
		! THIS SECTION IS NOT NEEDED FOR DIGITAL RESOLUTION ENCODERS.
		IF (HOME_DIGITAL(AXIS_INDEX))=0
			PTP(A_N(AXIS_INDEX)), IND(A_N(AXIS_INDEX)) + POW(2,(E_SCMUL(A_N(AXIS_INDEX))-3))*EFAC(A_N(AXIS_INDEX))	! Move to a middle of a quadrant, close to the index location
			TILL ^MST(A_N(AXIS_INDEX)).#MOVE, 30000
			WAIT 1000
			SET FPOS(A_N(AXIS_INDEX)) = FPOS(A_N(AXIS_INDEX)) - IND(A_N(AXIS_INDEX)) - GETCONF(265,A_N(AXIS_INDEX))-H_O(AXIS_INDEX)	! Repeatability correction
		END
		!END SIN/COS HOMING REPEATABILITY FIX SECTION
		!***********************
		IF (HOME_DIGITAL(AXIS_INDEX))=1
			SET FPOS(A_N(AXIS_INDEX))=FPOS(A_N(AXIS_INDEX))-IND(A_N(AXIS_INDEX))-H_O(AXIS_INDEX)  ! Set axis origin to the position of index = zero
		END
		
		HOME_FLAG(AXIS_INDEX)=1;			! SET HOME FLAG COMPLETE
		
	END ! END IF HOMING=TRUE		
RET

GantHome:
	! SETS A_N(GANT_AXES(0)) PARAMATERS IDENTICAL TO A_N(GANT_AXES(0))
	AXIS_LIMITS(GANT_AXES(1))=			AXIS_LIMITS(GANT_AXES(0))
	HOME_DIGITAL(GANT_AXES(1)) =		HOME_DIGITAL(GANT_AXES(0))
	HOME_DIR(GANT_AXES(1)) =			HOME_DIR(GANT_AXES(0))
	!H_O(GANT_AXES(1)) =					H_O(GANT_AXES(0))
	VELOCITY(GANT_AXES(1)) =			VELOCITY(GANT_AXES(0))
	COMMUT_ON(GANT_AXES(1)) =			COMMUT_ON(GANT_AXES(0))
	COMMUT_EXCITATION(GANT_AXES(1)) =	COMMUT_EXCITATION(GANT_AXES(0))
	AXIS_HOME(GANT_AXES(1)) =			AXIS_HOME(GANT_AXES(0))
	HARDLIMITS(GANT_AXES(1)) =			HARDLIMITS(GANT_AXES(0))
	RSOFTLIMIT(GANT_AXES(1)) =			RSOFTLIMIT(GANT_AXES(0))
	LSOFTLIMIT(GANT_AXES(1)) =			LSOFTLIMIT(GANT_AXES(0))
	
	!! A_N(GANT_AXES(1))
	MFLAGS(A_N(GANT_AXES(0))).25=0	! GANTRY MODE OFF
	MFLAGS(A_N(GANT_AXES(1))).25=0 	! GANTRY MODE OFF

	! SET TUNING PARAMETERS
	CALL TuningParameters
	
	! TURN OFF SOFT LIMITS FOR HOMING	
	FMASK(A_N(GANT_AXES(0))).5=0   ! MASK SOFTWARE RIGHT LIMIT	
	FMASK(A_N(GANT_AXES(0))).6=0	! MASK SOFTWARE LEFT LIMIT
	! TURN ON HARDWARE LIMITS FOR HOMING	
	FMASK(A_N(GANT_AXES(0))).0=1	! ACTIVATE RIGHT LIMIT
	FMASK(A_N(GANT_AXES(0))).1=1	! ACTIVATE LEFT LIMIT	
	! TURN OFF DEFAULT RESPONSE FOR HARDWARE LIMITS		
	FDEF(A_N(GANT_AXES(0))).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(GANT_AXES(0))).#RL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE

	! TURN OFF SOFT LIMITS FOR HOMING	
	FMASK(A_N(GANT_AXES(1))).5=0   ! MASK SOFTWARE RIGHT LIMIT	
	FMASK(A_N(GANT_AXES(1))).6=0	! MASK SOFTWARE LEFT LIMIT
	! TURN ON HARDWARE LIMITS FOR HOMING	
	FMASK(A_N(GANT_AXES(1))).0=1	! ACTIVATE RIGHT LIMIT
	FMASK(A_N(GANT_AXES(1))).1=1	! ACTIVATE LEFT LIMIT	
	! TURN OFF DEFAULT RESPONSE FOR HARDWARE LIMITS		
	FDEF(A_N(GANT_AXES(1))).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(GANT_AXES(1))).#RL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	
	!WAIT 1000 ! NEEDED FOR WIERD ENABLE FAILED ERROR BUG - DWA AND QW
	ENABLE (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))
	WAIT 1000
	
	IF MFLAGS(A_N(GANT_AXES(0))).9=0;
		IF(COMMUT_ON(GANT_AXES(0))=1)   !IF COMMUTATION IS SELECTED FOR AXIS
			MFLAGS(A_N(GANT_AXES(0))).9=0
			COMMUT (A_N(GANT_AXES(0))), (COMMUT_EXCITATION(GANT_AXES(0))),500 
			TILL MFLAGS(A_N(GANT_AXES(0))).9=1, 5000
		END
	END
	DISABLE A_N(GANT_AXES(0))
	WAIT 1000
	
	IF MFLAGS(A_N(GANT_AXES(1))).9=0;
		IF(COMMUT_ON(GANT_AXES(1))=1)   !IF COMMUTATION IS SELECTED FOR AXIS
			MFLAGS(A_N(GANT_AXES(1))).9=0
			COMMUT (A_N(GANT_AXES(1))), (COMMUT_EXCITATION(GANT_AXES(1))),500 
			TILL MFLAGS(A_N(GANT_AXES(1))).9=1, 5000
		END
	END
	ENABLE A_N(GANT_AXES(0))

	IF(AXIS_HOME(GANT_AXES(0))=1)
	
		!! GANT_AXES(0) !!		
		! HOMING ROUTINE FOR LINEAR WITH LIMITS				
		IF(AXIS_LIMITS(GANT_AXES(0))=1)               ! IF FOR AXIS WITH LIMITS
				! HOMING ROUTINE FOR LINEAR WITH LIMITS				
			IF(HOME_DIR(GANT_AXES(0)))=-1 				! IF AXIS DIRECTION IS -1
				!JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),--           	! MOVE TO THE LEFT LIMIT SWITCH
				JOG (A_N(GANT_AXES(0))),-
				JOG (A_N(GANT_AXES(1))),-
				!TILL (FAULT(A_N(GANT_AXES(0))).#LL | FAULT(A_N(GANT_AXES(1))).#LL), 60000   	! WAIT FOR THE LEFT LIMIT SWITCH ACTIVATION			
				WHILE (^FAULT(A_N(GANT_AXES(0))).#LL | ^FAULT(A_N(GANT_AXES(1))).#LL)
					BLOCK
						IF FAULT(A_N(GANT_AXES(0))).#LL
							HALT A_N(GANT_AXES(0))
						END
						IF FAULT(A_N(GANT_AXES(1))).#LL
							HALT A_N(GANT_AXES(1))
						END
					END
				END
				HALT (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))				
				WAIT 10				
				JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),++           	! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX
				TILL (^FAULT(A_N(GANT_AXES(0))).#LL & ^FAULT(A_N(GANT_AXES(1))).#LL), 60000  	! WAIT TO PROCEED UNTIL LEFT LIMIT SWITCH HAS RELEASED							
			END				
			! END IF HOMING IN NEGATIVE DIRECTION				
			IF(HOME_DIR(GANT_AXES(0)))=1 				! IF AXIS DIRECTION IS 1
				!JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),++           	! MOVE TO THE RIGHT LIMIT SWITCH
				JOG (A_N(GANT_AXES(0))),+
				JOG (A_N(GANT_AXES(1))),+
				!TILL (FAULT(A_N(GANT_AXES(0))).#RL | FAULT(A_N(GANT_AXES(1))).#RL), 60000   	! WAIT FOR THE RIGHT LIMIT SWITCH ACTIVATION			
				WHILE (^FAULT(A_N(GANT_AXES(0))).#RL | ^FAULT(A_N(GANT_AXES(1))).#RL)
					BLOCK
						IF FAULT(A_N(GANT_AXES(0))).#RL
							HALT A_N(GANT_AXES(0))
						END
						IF FAULT(A_N(GANT_AXES(1))).#RL
							HALT A_N(GANT_AXES(1))
						END
					END
				END
				HALT (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))				
				WAIT 10				
				JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),--           	! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX	
				TILL (^FAULT(A_N(GANT_AXES(0))).#RL & ^FAULT(A_N(GANT_AXES(1))).#RL), 60000  	! WAIT TO PROCEED UNTIL RIGHT LIMIT SWITCH HAS RELEASED						
			END
			! END IF HOMING IN POSITIVE DIRECTION
		END
		
		! HOMING ROUTINE FOR LINEAR WITHOUT LIMITS
		IF(AXIS_LIMITS(GANT_AXES(0))=2)               ! IF FOR AXIS WITHOUT LIMITS
			FMASK(A_N(GANT_AXES(0))).13=0
			FMASK(A_N(GANT_AXES(1))).13=0
			IF(HOME_DIR(AXIS_INDEX))=-1 				! IF AXIS DIRECTION IS -1
				JOG (A_N(GANT_AXES(0))),-									! MOVE TO THE LEFT HARD STOP 			
				JOG (A_N(GANT_AXES(1))),-
				!TILL ( (ABS(PE(A_N(GANT_AXES(0)))))>0.05 | (ABS(PE(A_N(GANT_AXES(1)))))>0.05 )	! UNTIL ABS VALUE OF POSITION ERROR IS > .05mm
				WHILE (^(ABS(PE(A_N(GANT_AXES(0)))))>0.05 | ^(ABS(PE(A_N(GANT_AXES(1)))))>0.05)
					IF (ABS(PE(A_N(GANT_AXES(0)))))>0.05
						HALT A_N(GANT_AXES(0))
					END
					IF (ABS(PE(A_N(GANT_AXES(1)))))>0.05
						HALT A_N(GANT_AXES(1))
					END
				END
				!HALT (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))
				WAIT 10
				JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),++									! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX
			END				
			! END IF HOMING IN NEGATIVE DIRECTION				
			IF(HOME_DIR(AXIS_INDEX))=1 				! IF AXIS DIRECTION IS 1
				JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),++									! MOVE TO THE RIGHT HARD STOP
				!TILL ( (ABS(PE(A_N(GANT_AXES(0)))))>0.05 | (ABS(PE(A_N(GANT_AXES(1)))))>0.05 )	! UNTIL ABS VALUE OF POSITION ERROR IS > .05mm
				WHILE (^(ABS(PE(A_N(GANT_AXES(0)))))>0.05 | ^(ABS(PE(A_N(GANT_AXES(1)))))>0.05)
					IF (ABS(PE(A_N(GANT_AXES(0)))))>0.05
						HALT A_N(GANT_AXES(0))
					END
					IF (ABS(PE(A_N(GANT_AXES(1)))))>0.05
						HALT A_N(GANT_AXES(1))
					END
				END
				!HALT (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))				
				WAIT 10				
				JOG (A_N(GANT_AXES(0)),A_N(GANT_AXES(1))),--									! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX
			END
			! END IF HOMING IN POSITIVE DIRECTION	
			WAIT 200
			FMASK(A_N(GANT_AXES(0))).13=1
			FMASK(A_N(GANT_AXES(1))).13=1
		END
		
		! SET HOME POSITION
		IST(A_N(GANT_AXES(0))).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)					
		IST(A_N(GANT_AXES(0))).#IND=0       	! RESET THE INDEX FLAG BIT				
		IST(A_N(GANT_AXES(1))).#IND=1       	! SET THE INDEX FLAG BIT (MUST DO THIS BEFORE SETTING IT TO ZERO)					
		IST(A_N(GANT_AXES(1))).#IND=0       	! RESET THE INDEX FLAG BIT				
		TILL (IST(A_N(GANT_AXES(0))).#IND & IST(A_N(GANT_AXES(1))).#IND), 60000    	! WAIT FOR INDEX READ
		WAIT 100	 
	 	HALT (GANT_AXES(0),GANT_AXES(1))
	 
		!***********************
		! NOTE THE SECTION BETWEEN THE "*"'S IS THE CODE THAT IS NECESSARY TO HAVE 
		! WHEN HOMING A SIN/COS ENCODER.  THIS CODE WAS PROVIDED BY ACS PER A TECH 
		! SUPPORT NOTE TO RESOLVE AN ISSUE WHERE HOMING WOULD NOT BE REPEATABLE 
		! BECAUSE IT WOULD NOT HOME TO THE SAME QUADRANT OF THE SIN/COS 20UM CYCLE
		! THUS HOMING REPEATABILITY COULD BE 5UM OR WORSE.
		! THIS SECTION IS NOT NEEDED FOR DIGITAL RESOLUTION ENCODERS. 
		IF (HOME_DIGITAL(GANT_AXES(0)))=0
			PTP(A_N(GANT_AXES(0))), IND(A_N(GANT_AXES(0))) + POW(2,(E_SCMUL(A_N(GANT_AXES(0)))-3))*EFAC(A_N(GANT_AXES(0)))	! Move to a middle of a quadrant, close to the index location
			TILL ^MST(A_N(GANT_AXES(0))).#MOVE, 30000
			WAIT 1000
			SET FPOS(A_N(GANT_AXES(0))) = FPOS(A_N(GANT_AXES(0))) - IND(A_N(GANT_AXES(0))) - GETCONF(265,A_N(GANT_AXES(0)))-H_O(GANT_AXES(0))	! Repeatability correction
		END
		!END SIN/COS HOMING REPEATABILITY FIX SECTION
		!***********************

		IF (HOME_DIGITAL(GANT_AXES(0)))=1
			SET FPOS(A_N(GANT_AXES(0)))=FPOS(A_N(GANT_AXES(0)))-IND(A_N(GANT_AXES(0)))-H_O(GANT_AXES(0))  ! Set axis origin to the position of index = zero
		END				
		
		!***********************
		! NOTE THE SECTION BETWEEN THE "*"'S IS THE CODE THAT IS NECESSARY TO HAVE 
		! WHEN HOMING A SIN/COS ENCODER.  THIS CODE WAS PROVIDED BY ACS PER A TECH 
		! SUPPORT NOTE TO RESOLVE AN ISSUE WHERE HOMING WOULD NOT BE REPEATABLE 
		! BECAUSE IT WOULD NOT HOME TO THE SAME QUADRANT OF THE SIN/COS 20UM CYCLE
		! THUS HOMING REPEATABILITY COULD BE 5UM OR WORSE.
		! THIS SECTION IS NOT NEEDED FOR DIGITAL RESOLUTION ENCODERS. 
		IF (HOME_DIGITAL(GANT_AXES(1)))=0
			PTP(A_N(GANT_AXES(1))), IND(A_N(GANT_AXES(1))) + POW(2,(E_SCMUL(A_N(GANT_AXES(1)))-3))*EFAC(A_N(GANT_AXES(1)))	! Move to a middle of a quadrant, close to the index location
			TILL ^MST(A_N(GANT_AXES(1))).#MOVE, 30000
			WAIT 1000
			SET FPOS(A_N(GANT_AXES(1))) = FPOS(A_N(GANT_AXES(1))) - IND(A_N(GANT_AXES(1))) - GETCONF(265,A_N(GANT_AXES(1)))-2.287867-H_O(GANT_AXES(0))	! Repeatability correction
		END
		!END SIN/COS HOMING REPEATABILITY FIX SECTION
		!***********************

		IF (HOME_DIGITAL(GANT_AXES(1)))=1
			SET FPOS(A_N(GANT_AXES(1)))=FPOS(A_N(GANT_AXES(1)))-IND(A_N(GANT_AXES(1)))-H_O(GANT_AXES(1))-H_O(GANT_AXES(0))  ! Set axis origin to the position of index = zero
		END
		
	END ! END IF HOMING=TRUE
	
	AXIS_INDEX = A_N(GANT_AXES(0))
	CALL SetLimitMasking		! SETS THE SOFT OR HARD LIMITS
	AXIS_INDEX = A_N(GANT_AXES(1))
	CALL SetLimitMasking		! SETS THE SOFT OR HARD LIMITS
	
	!!! DISABLE AXES AND SET GANTRY MODE ON, CHANGE TUNING PARAMETERS !!!
	DISABLE (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))      	! DISABLE THE AXIS
	
	MFLAGS(A_N(GANT_AXES(0))).25=1			! SET GANTRY MODE ON
	MFLAGS(A_N(GANT_AXES(1))).25=1			! SET GANTRY MODE ON

	! SET TUNING PARAMETERS FOR GANTRY MODE
	CALL TuningParametersGantry
	
	!!! RE-ENABLE AXES IN GANTRY MODE, DRIVE TO 0
	WAIT 1000
	ENABLE (A_N(GANT_AXES(0)),A_N(GANT_AXES(1)))

	HOME_FLAG(GANT_AXES(0))=1;			! SET HOME FLAG COMPLETE
	HOME_FLAG(GANT_AXES(1))=1;			! SET HOME FLAG COMPLETE
RET

RotNoLimHome:
	! HOMING ROUTINE FOR ROTARY WITHOUT LIMITS
	IF(HOME_DIR(AXIS_INDEX))=1 	! IF AXIS DIRECTION IS 1
		PTP/er (A_N(AXIS_INDEX)), -10
		WAIT 100
		JOG (A_N(AXIS_INDEX)),+	! MOVE IN THE POSITIVE DIRECTION
	END
	IF(HOME_DIR(AXIS_INDEX))=-1 	! IF AXIS DIRECTION IS -1
		PTP/er (A_N(AXIS_INDEX)), 10
		WAIT 100
		JOG (A_N(AXIS_INDEX)),-	! MOVE IN THE NEGATIVE DIRECTION
	END
RET

LinWithLimHome:
	! HOMING ROUTINE FOR LINEAR WITH LIMITS				
	IF(HOME_DIR(AXIS_INDEX))=-1 				! IF AXIS DIRECTION IS -1
		JOG (A_N(AXIS_INDEX)),-           	! MOVE TO THE LEFT LIMIT SWITCH 			
		TILL FAULT(A_N(AXIS_INDEX)).#LL, 60000   	! WAIT FOR THE LEFT LIMIT SWITCH ACTIVATION			
		HALT (A_N(AXIS_INDEX))				
		WAIT 50				
		JOG (A_N(AXIS_INDEX)),+           	! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX			
		TILL ^FAULT(A_N(AXIS_INDEX)).#LL, 60000  	! WAIT TO PROCEED UNTIL LEFT LIMIT SWITHC HAS RELEASED							
	END				
	! END IF HOMING IN NEGATIVE DIRECTION				
	IF(HOME_DIR(AXIS_INDEX))=1 				! IF AXIS DIRECTION IS 1
		JOG (A_N(AXIS_INDEX)),+           	! MOVE TO THE RIGHT LIMIT SWITCH 			
		TILL FAULT(A_N(AXIS_INDEX)).#RL, 60000   	! WAIT FOR THE RIGHT LIMIT SWITCH ACTIVATION			
		HALT (A_N(AXIS_INDEX))				
		WAIT 50				
		JOG (A_N(AXIS_INDEX)),-           	! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX			
		TILL ^FAULT(A_N(AXIS_INDEX)).#RL, 60000  	! WAIT TO PROCEED UNTIL RIGHT LIMIT SWITHC HAS RELEASED						
	END
	! END IF HOMING IN POSITIVE DIRECTION					
RET

LinNoLimHome:
	! HOMING ROUTINE FOR LINEAR WITHOUT LIMITS				
	FMASK(A_N(AXIS_INDEX)).13=0
	IF(HOME_DIR(AXIS_INDEX))=-1 				! IF AXIS DIRECTION IS -1
		JOG (A_N(AXIS_INDEX)),-           	! MOVE TO THE LEFT HARD STOP 			
		TILL (ABS(PE(A_N(AXIS_INDEX))))>0.05					! UNTIL ABS VALUE OF POSITION ERROR IS > .05mm 		
		HALT (A_N(AXIS_INDEX))				
		WAIT 100				
		JOG (A_N(AXIS_INDEX)),+           	! MOVE TO THE POSITIVE END LOOKING FOR THE ENCODER INDEX
	END				
	! END IF HOMING IN NEGATIVE DIRECTION				
	IF(HOME_DIR(AXIS_INDEX))=1 				! IF AXIS DIRECTION IS 1
		JOG (A_N(AXIS_INDEX)),+           	! MOVE TO THE RIGHT HARD STOP			
		TILL (ABS(PE(A_N(AXIS_INDEX))))>0.05					! UNTIL ABS VALUE OF POSITION ERROR IS > .05mm 				
		HALT (A_N(AXIS_INDEX))				
		WAIT 100				
		JOG (A_N(AXIS_INDEX)),-           	! MOVE TO THE NEGATIVE END LOOKING FOR THE ENCODER INDEX			
	END
	! END IF HOMING IN POSITIVE DIRECTION	
	WAIT 200
	FMASK(A_N(AXIS_INDEX)).13=1
RET

SetLimitMasking:
	IF (HARDLIMITS(AXIS_INDEX)=0) ! IF SOFT LIMITS SHOULD BE USED
		FMASK(A_N(AXIS_INDEX)).0 = 0 ! MASK THE RIGHT HARD LIMIT
		FMASK(A_N(AXIS_INDEX)).1 = 0 ! MASK THE LEFT HARD LIMIT
		FDEF(A_N(AXIS_INDEX)).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE
		FDEF(A_N(AXIS_INDEX)).#RL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		FMASK(A_N(AXIS_INDEX)).5 = 1 ! UNMASK THE RIGHT SOFT LIMIT
		FMASK(A_N(AXIS_INDEX)).6 = 1 ! UNMASK THE LEFT SOFT LIMIT
		FDEF(A_N(AXIS_INDEX)).#SLL=1 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE
		FDEF(A_N(AXIS_INDEX)).#SRL=1   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		SRLIMIT(A_N(AXIS_INDEX)) = RSOFTLIMIT(AXIS_INDEX) ! SET THE RIGHT SOFT LIMIT LOCATION
		SLLIMIT(A_N(AXIS_INDEX)) = LSOFTLIMIT(AXIS_INDEX) ! SET THE LEFT SOFT LIMIT LOCATION
	END
	IF (HARDLIMITS(AXIS_INDEX)=1) ! IF HARD LIMITS SHOULD BE USED
		FMASK(A_N(AXIS_INDEX)).0 = 1 ! UNMASK THE RIGHT HARD LIMIT
		FMASK(A_N(AXIS_INDEX)).1 = 1 ! UNMASK THE LEFT HARD LIMIT
		FDEF(A_N(AXIS_INDEX)).#LL=1 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE
		FDEF(A_N(AXIS_INDEX)).#RL=1   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		FMASK(A_N(AXIS_INDEX)).5 = 0 ! MASK THE RIGHT SOFT LIMIT
		FMASK(A_N(AXIS_INDEX)).6 = 0 ! MASK THE LEFT SOFT LIMIT
		FDEF(A_N(AXIS_INDEX)).#SLL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE
		FDEF(A_N(AXIS_INDEX)).#SRL=0   ! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		SRLIMIT(A_N(AXIS_INDEX)) = 99999 ! SET THE RIGHT SOFT LIMIT LOCATION
		SLLIMIT(A_N(AXIS_INDEX)) = -99999 ! SET THE LEFT SOFT LIMIT LOCATION
	END
RET


!!!!! ERROR COMPENSTATION !!!!!

! ErrorComp0 - sets default connections for all axes

! ErrorComp1 - sets 2D x-lda, y-lda x-str & y-str, ortho (T_1) for standard xy
!	 - LdaX, LdaY, StrX, StrY, T_1, YawX, YawY

! ErrorCompZ1 - sets 1D z-lda for standard z
!	 - LdaZ
! ErrorCompZ2 - sets 1D z-lda, 2D x-flatness & y-flatness for standard z
!	 - LdaZ, FlatX, FlatY

ErrorComp0:	! RESET DEFAULT CONNECTIONS
	AXIS_INDEX=0   ! SET THE AXIS_INDEX
	WHILE(AXIS_INDEX < AXIS_QTY)
		IF MFLAGS(A_N(AXIS_INDEX)).17=0
			CONNECT RPOS(A_N(AXIS_INDEX))=APOS(A_N(AXIS_INDEX))
		END
		MFLAGS(A_N(AXIS_INDEX)).17=1	! APPLY THE DEFAULT CONNECTION
		AXIS_INDEX=AXIS_INDEX+1	!INCREMENT THE AXIS_INDEX
	END
	WAIT 100
RET

ErrorComp1:	!! X AND Y LDA COMPENSATION, WITH STRAIGHTNESS AND ORTHOGONALITY
	IF SYSTYPE=0
		I_X1=STD_AXES(0)
		I_Y=STD_AXES(1)
	END
	IF SYSTYPE=2
		I_X1=GANT_AXES(0)
		I_X2=GANT_AXES(1)
		I_Y=GANT_AXES(2)
	END
	
	CALL ErrorCompTables
	! RESET DEFAULT CONNECTIONS
	IF MFLAGS(A_N(I_X1)).17=0
		CONNECT RPOS(A_N(I_X1))=APOS(A_N(I_X1))
	END
	IF MFLAGS(A_N(I_Y)).17=0
		CONNECT RPOS(A_N(I_Y))=APOS(A_N(I_Y))
	END
	MFLAGS(A_N(I_X1)).17=1
	MFLAGS(A_N(I_Y)).17=1
	IF SYSTYPE=2
		IF MFLAGS(A_N(I_X2)).17=0
			CONNECT RPOS(A_N(I_X2))=APOS(A_N(I_X2))
		END
		MFLAGS(A_N(I_X2)).17=1
	END
	WAIT 100
	
	! SET NON-DEFAULT CONNECTIONS
	MFLAGS(A_N(I_X1)).17=0
	! X=X-2D.X.LDA-2D.Y.STRAIGHTNESS
	CONNECT RPOS(A_N(I_X1))=APOS(A_N(I_X1))-MAP2N(APOS(A_N(I_X1)),APOS(A_N(I_Y)),LdaX,StepX,XStepY)/1000-MAP2N(APOS(A_N(I_Y)),APOS(A_N(I_X1)),StrY,StepY,YStepX)/1000+((APOS(A_N(I_Y))+H_O(I_Y))*SIN(T_1)+(APOS(A_N(I_Y))+H_O(I_Y))*SIN(T_1)*TAN(T_1)*TAN(T_1))
	DEPENDS (A_N(I_X1)),(A_N(I_X1),A_N(I_Y))		
	MFLAGS(A_N(I_Y)).17=0
	! Y=Y-2D.Y.LDA-2D.X.STRAIGHTNESS
	CONNECT RPOS(A_N(I_Y))=APOS(A_N(I_Y))-MAP2N(APOS(A_N(I_Y)),APOS(A_N(I_X1)),LdaY,StepY,YStepX)/1000-MAP2N(APOS(A_N(I_X1)),APOS(A_N(I_Y)),StrX,StepX,XStepY)/1000+((APOS(A_N(I_Y))+H_O(I_Y))*TAN(T_1)*TAN(T_1))
	DEPENDS (A_N(I_Y)),(A_N(I_X1),A_N(I_Y))
	IF SYSTYPE=2
		MFLAGS(A_N(I_X2)).17=0
		CONNECT RPOS(A_N(I_X2))=APOS(A_N(I_X2))-MAPN(APOS(A_N(I_X1)),StepX,YawX)/1000-MAPN(APOS(A_N(I_Y)),StepY,YawY)/1000! XYAW=XYAW-XYawX-YYAW
		DEPENDS (A_N(I_X2)),(A_N(I_X2),A_N(I_Y),A_N(I_X1))
	END

	! IF COMP TABLES ARE USED, THIS SECTION DISABLES THE DEFAULT RESPONE (KILL) TO HARD AND SOFT LIMITS ON AXES 0 AND 1.
	! THE RESPONSE IS REPLACED WITH A HALT USING ON/RET COMMANDS IN A DIFFERENT BUFFER.
	FDEF(A_N(I_X1)).#LL=0 		! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_X1)).#RL=0   	! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_X1)).#SLL=0		! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_X1)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Y)).#LL=0 		! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Y)).#RL=0   		! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Y)).#SLL=0 		! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Y)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
	IF SYSTYPE=2
		FDEF(A_N(I_X2)).#LL=0 		! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
		FDEF(A_N(I_X2)).#RL=0   	! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
		FDEF(A_N(I_X2)).#SLL=0 		! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
		FDEF(A_N(I_X2)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
	END
	
RET
	
ErrorCompZ1: 
	IF SYSTYPE=0
		I_Z=STD_AXES(2)
	END
	IF SYSTYPE=2
		I_Z=GANT_AXES(3)
		I_Z2=GANT_AXES(4)
	END
	
	CALL ErrorCompTables
	! RESET DEFAULT CONNECTIONS
	IF MFLAGS(A_N(I_Z)).17=0
		CONNECT RPOS(A_N(I_Z))=APOS(A_N(I_Z))
	END
	MFLAGS(A_N(I_Z)).17=1
	IF MFLAGS(A_N(I_Z2)).17=0
		CONNECT RPOS(A_N(I_Z2))=APOS(A_N(I_Z2))
	END
	MFLAGS(A_N(I_Z2)).17=1
	WAIT 100
	
	! SET NON-DEFAULT CONNECTIONS
	MFLAGS(A_N(I_Z)).17=0
	CONNECT RPOS(A_N(I_Z))=APOS(A_N(I_Z))-MAPN(APOS(A_N(I_Z)),StepZ,LdaZ)/1000	
	DEPENDS (A_N(I_Z)),(A_N(I_Z))
	MFLAGS(A_N(I_Z2)).17=0
	CONNECT RPOS(A_N(I_Z2))=APOS(A_N(I_Z2))-MAPN(APOS(A_N(I_Z2)),StepZ2,LdaZ2)/1000	
	DEPENDS (A_N(I_Z2)),(A_N(I_Z2))
	
	! IF COMP TABLES ARE USED, THIS SECTION DISABLES THE DEFAULT RESPONE (KILL) TO HARD AND SOFT LIMITS ON AXIS 2.
	! THE RESPONSE IS REPLACED WITH A HALT USING ON/RET COMMANDS IN A DIFFERENT BUFFER.
	FDEF(A_N(I_Z)).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z)).#RL=0   	! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Z)).#SLL=0 	! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Z2)).#LL=0 	! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z2)).#RL=0   	! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Z2)).#SLL=0 	! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z2)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
RET

ErrorCompZ2: 
	IF SYSTYPE=0
		I_X1=STD_AXES(0)
		I_Y=STD_AXES(1)
		I_Z=STD_AXES(2)
	END
	IF SYSTYPE=2
		I_X1=GANT_AXES(0)
		I_Y=GANT_AXES(2)
		I_Z=GANT_AXES(3)
		I_Z2=GANT_AXES(4)
	END
	
	CALL ErrorCompTables
	! RESET DEFAULT CONNECTIONS
	IF MFLAGS(A_N(I_Z)).17=0
		CONNECT RPOS(A_N(I_Z))=APOS(A_N(I_Z))
	END
	MFLAGS(A_N(I_Z)).17=1
	IF MFLAGS(A_N(I_Z2)).17=0
		CONNECT RPOS(A_N(I_Z2))=APOS(A_N(I_Z2))
	END
	MFLAGS(A_N(I_Z2)).17=1
	WAIT 100
	
	! SET NON-DEFAULT CONNECTIONS
	MFLAGS(A_N(I_Z)).17=0
	CONNECT RPOS(A_N(I_Z))=APOS(A_N(I_Z))-MAPN(APOS(A_N(I_Z)),StepZ,LdaZ)/1000-MAP2N(APOS(A_N(I_X1)),APOS(A_N(I_Y)),FlatX,StepX,XStepY)/1000-MAP2N(APOS(A_N(I_Y)),APOS(A_N(I_X1)),FlatY,StepY,YStepX)/1000 ! Z=Z-ZLDA-XFLATNESS-YFLATNESS
	DEPENDS (A_N(I_Z)),(A_N(I_X1),A_N(I_Y),A_N(I_Z))
	MFLAGS(A_N(I_Z2)).17=0
	CONNECT RPOS(A_N(I_Z2))=APOS(A_N(I_Z2))-MAPN(APOS(A_N(I_Z2)),StepZ2,LdaZ2)/1000-MAP2N(APOS(A_N(I_X1)),APOS(A_N(I_Y)),FlatX2,StepX,XStepY)/1000-MAP2N(APOS(A_N(I_Y)),APOS(A_N(I_X1)),FlatY2,StepY,YStepX)/1000 ! Z=Z-ZLDA-XFLATNESS-YFLATNESS
	DEPENDS (A_N(I_Z2)),(A_N(I_X1),A_N(I_Y),A_N(I_Z2))
	
	! IF COMP TABLES ARE USED, THIS SECTION DISABLES THE DEFAULT RESPONE (KILL) TO HARD AND SOFT LIMITS ON AXES 0 AND 1.
	! THE RESPONSE IS REPLACED WITH A HALT USING ON/RET COMMANDS IN A DIFFERENT BUFFER.
	FDEF(A_N(I_Z)).#LL=0		! DISABLE THE AXIS LEFT HARDWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z)).#RL=0		! DISABLE THE AXIS RIGHT HARDWARE LIMIT DEFAULT RESPONSE
	FDEF(A_N(I_Z)).#SLL=0		! ENABLE THE AXIS LEFT SOFTWARE LIMIT DEFAULT RESPONSE	
	FDEF(A_N(I_Z)).#SRL=0   	! ENABLE THE AXIS RIGHT SOFTWARE LIMIT DEFAULT RESPONSE
RET


!!!!!!!!!! REV HISTORY !!!!!!!!!!
!
! REV 002 - ADDING OF COMMENTS DESCRIBING THE SIN/COS HOMING REPEATABILITY FIX
!     ALL CHANGES FOR REV 002 ARE ENCLOSED IN LINES WITH "*"'S
!     COMMENTS ADDED 5/30/12 BY NB OF ALIO INDUSTRIES
!
! REV 003 - ADDED A DIGITAL VARIABLE TO DEFINE IF AN AXIS IS ANALOG OF DIGITAL.
!     ADDED LOGIC TO HOME DIFFERENTLY DEPENDING ON DIGITAL OR ANALOG INTERFACES.
!
! REV 004 - ADDED LOGIC TO CHANGE NUMBER OF AXIS, CHOOSE LIMIT LOGIC, AND CHOOSE COMPENSATION LOGIC
!     CHANGED LOOP LOGIC, ADDED COMMUTATION OPTION
!     ADDED VELOCITY, AXIS_INDEX, AXIS_QTY, AXIS_LIMITS, A_N AND AXIS_COMP VARIABLES.
!     MINOR REORGANIZATION OF CODE.
!
! REV 005 - MOVED COMMUTION TO PER-AXIS INSTEAD OF GLOBAL
!
! REV 006 - CLARIFIED COMPENSATION TABLE FUNCTION, ADDED IMP_PROFILE FUNCTION
!
! REV 007 - ADDED ADDITIONAL IMP_PROFILE FUNCTIONS TO WORK BETTER WITH LEGACY CODE
!           NOTE: COMMUTATION AND HOMING WILL NOT WORK WHILE IMP_PROFILE IS ENABLED BECAUSE THE DEFAULT VALUES ARE 0
!
! REV 008 - ADDED CHECK TO SEE IF AXIS HAS ALREADY BE COMMUTATED
!
! REV 009 - ADDED SETSPEEDVAR VARIABLE
!
! REV 010 - FIXED A FEW LOGIC PROBLEMS WHEN SETTING FIRST AXIS NAME TO ANYTHING OTHER THAN 0 -A_N(0)-
!
! REV 011 - ADDED THE OPTION TO HOME WITHOUT LIMITS (USING HARD STOPS)
!
! REV 012 - CHANGED H_O TO A REAL
!
! REV 013 - CHANGED COMPENSATION TABLE DEFAULT CONNECTIONS AND SYNTAX
!
! REV 014 - UPDATED COMPENSATION TABLE DEFAULT CONNECTIONS AND SYNTAX
!
! REV 015 - UPDATED COMPENSATION TABLE DEFAULT CONNECTIONS AND SYNTAX, NEW 2D COMP TABLE METHOD IMPLEMENTED
!
! REV 016 - ADDED XY ORTHOGONALITY COMPENSATION (IN 2D SECTION)
!
! REV 017 - ADDED LINE TO TURN INDEX ON BEFORE TURNING IT BACK OFF (OTHERWISE POTENTIAL TO MISS THE INDEX MARK DUE TO MISSING RISING EDGE DEPENDING ON HOW THE DSP BOOTS)
!
! REV 018 - ADDED 5TH AXIS SETSPEEDVARS AND IMP_PROFILE
!
! REV 019 - ADDED THE ABILITY TO USE THE ROUTINE FOR A HYBRID HEXAPOD (EXCLUDING THE ROTARY AXIS)
!
! REV 020 - FIXED PROBLEM WITH AXIS 4 ON A 2X UDM SETUP (USING FOURPLACE VARIABLE). REMOVED ACCIDENTAL "START 2, 1" COMMAND THAT WAS ADDED IN REV 19.
!
! REV 021 - ADDED SECTION AT END TO DISABLE DEFAULT RESPONSE OF "KILL" IF 1D OR 2D COMP TABLES ARE USED.
!
! REV 022 - CORRECTED LOGIC FROM REV 021 (SOFTWARE LIMIT DEFAULT RESPONSE WAS NOT DISABLED). ADDED THE ABILITY TO DISABLE HARD LIMITS AND SET THE SOFT LIMITS ON A PER AXIS BASIS.
!
! REV 023 - REMOVED LINES 172-177 FROM REV 22 TO CORRECT PROBLEM WHEN ATTEMPTING TO HOME INDIVIDUAL AXES. THE HOME_FLAG VARIABLE WAS SET TO 0 ON ALL AXES EVEN IF ONLY A SINGLE AXIS WAS BEING HOMED.
!
! REV 024 - ADDED A 10 DEGREE PRE-MOVE BEFORE THE ROTARY SCANS FOR THE REF MARK. THIS WILL HELP PREVENT AN UNNECESSARY FULL ROTATION ON THE ROTARY WHEN HOMING.
!
! REV 025 - MADE SIGNIFICANT CHANGES TO THE HYHEX SECTION TO ALLOW FOR LINKS ON AXES 2,4,5 INSTEAD OF 2,3,4. THESE NUMBERS ARE NOW DICTATED BY THE A_N(X) VARIABLE. A_N CAN BE ANY AXIS, BUT XY IS ON CODE AXES 0/1, TRIPOD ON 2/3/4, ROTARY ON 5. MADE GENERAL CHANGES TO ALLOW FOR A 6 AXIS HYBRID HEXAPOD (PREVIOUSLY ONLY 5 AXIS WAS ALLOWED). MADE CHANGES TO THE IMP AND SETSPEEDVARS SECTION AT THE END TO REMOVE THE NEED TO COMMENTING AXES IF PHYSICAL SETUP HAS LESS DRIVES AVAILABLE.
!
! REV 026 - ADDED SERIAL NUMBER FIELD TO THE AXIS PARAMETERS. THIS FIELD IS INFORMATIONAL ONLY.
!
! REV 027 - ADDED THE ABILITY FOR COMP TABLES TO WORK CORRECTLY WITH AN OFFSET ON AXES 0 AND/OR 1.
!
! REV 028 - Changed Orthagonality Compensation to be T_1 dependent.
!
! REV 029 - Added If HYHEX=1 -> START 2,1 at end for transition to Kinematics.
!
! REV 030 - ADDED UpdateUPOS VARIABLE AND TOGGLE FOR COMPENSATED FPOS (UPOS) CALCULATIONS. ADDED "/e" TO LINE 848. THE MISSING "E" WOULD CAUSE PROBLEMS IF USING AN AXIS 5 HOMING OFFSET AND KINEMATICS.
!
! REV 031 - Reformatted code. Functionally the same as REV 30.
!
! REV 032 - REMOVED IMP_Profile FUNCTIONALITY
!			SET UP SUBROUTINES TO SIMPLIFY MAIN ROUTINE
!			ADDED GANTRY
!
! REV 033 - ADDED TAN() TO ERROR COMP TO REMOVE SMALL ANGLE THEOREM (1192 AND 1196)
!			ADDED H_O TO T_1 CALC IN ERROR COMP
! 			UPDATED A COUPLE VARIABLES (MOVED T_1 DEFINITION)
!
! REV 034 - ADDED HOME_FLAG RESET TO 'INITIALIZE' SUB-ROUTINE TO PREVENT ON-RET CODE FOR ERROR COMP FROM FIRING
!			REMOVED TAN(T_1)'S FROM ERROR COMP AND UPDATED ORTHO (T_1) NOTE
!
! REV 035 - COMMENTED OUT ETYPE, CHANGED GANTRY TO MOVE TO GANT_ORTHO (NOT 0)
!
! REV 036 - ADDED OPTION TO USE ARRAY COMP TABLES (XYCOMP=3) - CURRENTLY ONLY WORKS WITH SYSTYPE=0
!			UPDATED ORTHO (T_1) CODE FOR XYCOMP=2
!           THE ABOVE CHANGES PAIR WITH ON/RET CODE REV 004 AND UPOS CODE REV 003
!           IF AXIS_LIMITS(0)=2, INCREASED ACC/DEC/JERK/KDEC BY 10X TO STOP FASTER
!           ADDED UpdateUPOS=0 BEFORE UpdateUPOS=1 IN ORDER TO FORCE THE STATE CHANGE
!           MOVED ALL VARIABLE DEFENITIONS TO THE TOP OF THE BUFFER (CLEANUP, NO FUNCTIONALITY CHANGE)
!
! REV 037 - ADDED FLATNESS COMPENSTATION FOR XY (FlatX and FlatY)
!			ADDED COMPENSATION FOR Y YAW (YawY)
!			CHANGED TO ALWAYS-2D COMPENSATIONS
!			REMOVED HARD-CODING FOR MOST STUFF (IE, GANT_AXES INSTEAD OF 0,1; USES THE INDEX VARIABLES IN ERROR COMP)
!			CHANGED VARIABLES TO PREVENT LINE CHARACTER LIMIT: AXIS_NAME -> A_N, INDEX_X1 -> I_X1, INDEX_X2 -> I_X2, INDEX_Y -> I_Y, INDEX_Z -> I_Z, HOME_OFFSET -> H_O, THETA -> T_1
!
! REV 038 - CHANGED TO A SUBROUTINE FOR COMMUTATION (COMM_AND_FLAGS) -> INTENDED TO MAKE SINGLE AXIS MOVEMENT BEFORE HOMING EASIER (SUCH AS GETTING THE Z OUT OF THE WAY)
!			ADDED SPLIT ALL TO INITIALIZE FUNCTION
!			REMOVED STIFF GANTRY SUPPORT
!			CHANGED ORDER OF GANTRY HOMING, INCLUDED WHILE LOOP TO ALLOW BOTH GANTRY AXES TO HOME AT ONCE
!			ADDED AND ADJUSTED CODE IN MAIN ROUTINE FOR HOME_OFFSET ERROR COMPENSTATION
!			ADDED WAIT FOR ALL MOTION TO STOP (SO BUFFER 1 IS STILL RUNNING UNTIL MOTION IS OVER)
!			CHANGED YAW COMPENSATION TO BE IN UM (ADDED /1000)
!			
!			
